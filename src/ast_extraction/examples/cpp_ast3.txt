translation_unit: /* Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

#include "tensorflow/cc/tools/freeze_saved_model.h"

#include <cstddef>
#include <memory>
#include <unordered_set>
#include <vector>

#include "absl/status/status.h"
#include "tensorflow/cc/framework/ops.h"
#include "tensorflow/cc/framework/scope.h"
#include "tensorflow/cc/ops/array_ops.h"
#include "tensorflow/cc/ops/const_op.h"
#include "tensorflow/cc/ops/math_ops.h"
#include "tensorflow/cc/ops/resource_variable_ops.h"
#include "tensorflow/cc/ops/state_ops.h"
#include "tensorflow/cc/saved_model/loader.h"
#include "xla/tsl/lib/core/status_test_util.h"
#include "xla/tsl/platform/errors.h"
#include "tensorflow/core/framework/function_testlib.h"
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/tensor.h"
#include "tensorflow/core/framework/tensor_testutil.h"
#include "tensorflow/core/framework/types.pb.h"
#include "tensorflow/core/framework/versions.pb.h"
#include "tensorflow/core/platform/status.h"
#include "tensorflow/core/platform/test.h"
#include "tensorflow/core/platform/types.h"
#include "tensorflow/core/protobuf/meta_graph.pb.h"
#include "tensorflow/core/public/session.h"
#include "tensorflow/core/public/session_options.h"

namespace tensorflow {
namespace {

class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
};

TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}

TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

}  // namespace
}  // namespace tensorflow

 comment: /* Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
 preproc_include: #include "tensorflow/cc/tools/freeze_saved_model.h"

  #include: #include
  string_literal: "tensorflow/cc/tools/freeze_saved_model.h"
   ": "
   string_content: tensorflow/cc/tools/freeze_saved_model.h
   ": "
 preproc_include: #include <cstddef>

  #include: #include
  system_lib_string: <cstddef>
 preproc_include: #include <memory>

  #include: #include
  system_lib_string: <memory>
 preproc_include: #include <unordered_set>

  #include: #include
  system_lib_string: <unordered_set>
 preproc_include: #include <vector>

  #include: #include
  system_lib_string: <vector>
 preproc_include: #include "absl/status/status.h"

  #include: #include
  string_literal: "absl/status/status.h"
   ": "
   string_content: absl/status/status.h
   ": "
 preproc_include: #include "tensorflow/cc/framework/ops.h"

  #include: #include
  string_literal: "tensorflow/cc/framework/ops.h"
   ": "
   string_content: tensorflow/cc/framework/ops.h
   ": "
 preproc_include: #include "tensorflow/cc/framework/scope.h"

  #include: #include
  string_literal: "tensorflow/cc/framework/scope.h"
   ": "
   string_content: tensorflow/cc/framework/scope.h
   ": "
 preproc_include: #include "tensorflow/cc/ops/array_ops.h"

  #include: #include
  string_literal: "tensorflow/cc/ops/array_ops.h"
   ": "
   string_content: tensorflow/cc/ops/array_ops.h
   ": "
 preproc_include: #include "tensorflow/cc/ops/const_op.h"

  #include: #include
  string_literal: "tensorflow/cc/ops/const_op.h"
   ": "
   string_content: tensorflow/cc/ops/const_op.h
   ": "
 preproc_include: #include "tensorflow/cc/ops/math_ops.h"

  #include: #include
  string_literal: "tensorflow/cc/ops/math_ops.h"
   ": "
   string_content: tensorflow/cc/ops/math_ops.h
   ": "
 preproc_include: #include "tensorflow/cc/ops/resource_variable_ops.h"

  #include: #include
  string_literal: "tensorflow/cc/ops/resource_variable_ops.h"
   ": "
   string_content: tensorflow/cc/ops/resource_variable_ops.h
   ": "
 preproc_include: #include "tensorflow/cc/ops/state_ops.h"

  #include: #include
  string_literal: "tensorflow/cc/ops/state_ops.h"
   ": "
   string_content: tensorflow/cc/ops/state_ops.h
   ": "
 preproc_include: #include "tensorflow/cc/saved_model/loader.h"

  #include: #include
  string_literal: "tensorflow/cc/saved_model/loader.h"
   ": "
   string_content: tensorflow/cc/saved_model/loader.h
   ": "
 preproc_include: #include "xla/tsl/lib/core/status_test_util.h"

  #include: #include
  string_literal: "xla/tsl/lib/core/status_test_util.h"
   ": "
   string_content: xla/tsl/lib/core/status_test_util.h
   ": "
 preproc_include: #include "xla/tsl/platform/errors.h"

  #include: #include
  string_literal: "xla/tsl/platform/errors.h"
   ": "
   string_content: xla/tsl/platform/errors.h
   ": "
 preproc_include: #include "tensorflow/core/framework/function_testlib.h"

  #include: #include
  string_literal: "tensorflow/core/framework/function_testlib.h"
   ": "
   string_content: tensorflow/core/framework/function_testlib.h
   ": "
 preproc_include: #include "tensorflow/core/framework/graph.pb.h"

  #include: #include
  string_literal: "tensorflow/core/framework/graph.pb.h"
   ": "
   string_content: tensorflow/core/framework/graph.pb.h
   ": "
 preproc_include: #include "tensorflow/core/framework/tensor.h"

  #include: #include
  string_literal: "tensorflow/core/framework/tensor.h"
   ": "
   string_content: tensorflow/core/framework/tensor.h
   ": "
 preproc_include: #include "tensorflow/core/framework/tensor_testutil.h"

  #include: #include
  string_literal: "tensorflow/core/framework/tensor_testutil.h"
   ": "
   string_content: tensorflow/core/framework/tensor_testutil.h
   ": "
 preproc_include: #include "tensorflow/core/framework/types.pb.h"

  #include: #include
  string_literal: "tensorflow/core/framework/types.pb.h"
   ": "
   string_content: tensorflow/core/framework/types.pb.h
   ": "
 preproc_include: #include "tensorflow/core/framework/versions.pb.h"

  #include: #include
  string_literal: "tensorflow/core/framework/versions.pb.h"
   ": "
   string_content: tensorflow/core/framework/versions.pb.h
   ": "
 preproc_include: #include "tensorflow/core/platform/status.h"

  #include: #include
  string_literal: "tensorflow/core/platform/status.h"
   ": "
   string_content: tensorflow/core/platform/status.h
   ": "
 preproc_include: #include "tensorflow/core/platform/test.h"

  #include: #include
  string_literal: "tensorflow/core/platform/test.h"
   ": "
   string_content: tensorflow/core/platform/test.h
   ": "
 preproc_include: #include "tensorflow/core/platform/types.h"

  #include: #include
  string_literal: "tensorflow/core/platform/types.h"
   ": "
   string_content: tensorflow/core/platform/types.h
   ": "
 preproc_include: #include "tensorflow/core/protobuf/meta_graph.pb.h"

  #include: #include
  string_literal: "tensorflow/core/protobuf/meta_graph.pb.h"
   ": "
   string_content: tensorflow/core/protobuf/meta_graph.pb.h
   ": "
 preproc_include: #include "tensorflow/core/public/session.h"

  #include: #include
  string_literal: "tensorflow/core/public/session.h"
   ": "
   string_content: tensorflow/core/public/session.h
   ": "
 preproc_include: #include "tensorflow/core/public/session_options.h"

  #include: #include
  string_literal: "tensorflow/core/public/session_options.h"
   ": "
   string_content: tensorflow/core/public/session_options.h
   ": "
 namespace_definition: namespace tensorflow {
namespace {

class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
};

TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}

TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

}  // namespace
}
  namespace: namespace
  namespace_identifier: tensorflow
  declaration_list: {
namespace {

class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
};

TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}

TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

}  // namespace
}
   {: {
   namespace_definition: namespace {

class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
};

TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}

TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

}
    namespace: namespace
    declaration_list: {

class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
};

TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}

TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}

TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}

TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}

TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}

}
     {: {
     class_specifier: class FreezeTest : public ::testing::Test {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
}
      class: class
      type_identifier: FreezeTest
      base_class_clause: : public ::testing::Test
       :: :
       access_specifier: public
        public: public
       qualified_identifier: ::testing::Test
        ::: ::
        qualified_identifier: testing::Test
         namespace_identifier: testing
         ::: ::
         type_identifier: Test
      field_declaration_list: {
 protected:
  void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }

  // Builds a SignatureDef with the provided `inputs` and `outputs`.
  SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }

  // Adds `signature_def` to `saved_model_bundle` under `key`.
  void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }

  // Adds an initialized session to `saved_model_bundle` using `graph_def` and
  // initializing with `init_node`.
  absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }

  // Adds `graph_def` to `saved_model_bundle` and initializes a session with
  // `init_node`.
  absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }

  // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
  // `saved_model_bundle` and initializes a session with `init_node`.
  absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }

  // Runs and compares the outputs of `tensor_name` on both the
  // `unfrozen_session` and the `frozen_graph_def.
  void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }

  void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }

  void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
}
       {: {
       access_specifier: protected
        protected: protected
       :: :
       function_definition: void GraphDefEqual(const GraphDef& actual, const GraphDef& expected) {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }
        primitive_type: void
        function_declarator: GraphDefEqual(const GraphDef& actual, const GraphDef& expected)
         field_identifier: GraphDefEqual
         parameter_list: (const GraphDef& actual, const GraphDef& expected)
          (: (
          parameter_declaration: const GraphDef& actual
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & actual
            &: &
            identifier: actual
          ,: ,
          parameter_declaration: const GraphDef& expected
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & expected
            &: &
            identifier: expected
          ): )
        compound_statement: {
    EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
  }
         {: {
         expression_statement: EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString());
          call_expression: EXPECT_EQ(actual.ShortDebugString(), expected.ShortDebugString())
           identifier: EXPECT_EQ
           argument_list: (actual.ShortDebugString(), expected.ShortDebugString())
            (: (
            call_expression: actual.ShortDebugString()
             field_expression: actual.ShortDebugString
              identifier: actual
              .: .
              field_identifier: ShortDebugString
             argument_list: ()
              (: (
              ): )
            ,: ,
            call_expression: expected.ShortDebugString()
             field_expression: expected.ShortDebugString
              identifier: expected
              .: .
              field_identifier: ShortDebugString
             argument_list: ()
              (: (
              ): )
            ): )
          ;: ;
         }: }
       comment: // Builds a SignatureDef with the provided `inputs` and `outputs`.
       function_definition: SignatureDef BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs) {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }
        type_identifier: SignatureDef
        function_declarator: BuildSignatureDef(const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs)
         field_identifier: BuildSignatureDef
         parameter_list: (const std::unordered_set<string>& inputs,
                                 const std::unordered_set<string>& outputs)
          (: (
          parameter_declaration: const std::unordered_set<string>& inputs
           type_qualifier: const
            const: const
           qualified_identifier: std::unordered_set<string>
            namespace_identifier: std
            ::: ::
            template_type: unordered_set<string>
             type_identifier: unordered_set
             template_argument_list: <string>
              <: <
              type_descriptor: string
               type_identifier: string
              >: >
           reference_declarator: & inputs
            &: &
            identifier: inputs
          ,: ,
          parameter_declaration: const std::unordered_set<string>& outputs
           type_qualifier: const
            const: const
           qualified_identifier: std::unordered_set<string>
            namespace_identifier: std
            ::: ::
            template_type: unordered_set<string>
             type_identifier: unordered_set
             template_argument_list: <string>
              <: <
              type_descriptor: string
               type_identifier: string
              >: >
           reference_declarator: & outputs
            &: &
            identifier: outputs
          ): )
        compound_statement: {
    SignatureDef signature_def;
    for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
    for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
    return signature_def;
  }
         {: {
         declaration: SignatureDef signature_def;
          type_identifier: SignatureDef
          identifier: signature_def
          ;: ;
         for_range_loop: for (const string& input : inputs) {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
          for: for
          (: (
          type_qualifier: const
           const: const
          type_identifier: string
          reference_declarator: & input
           &: &
           identifier: input
          :: :
          identifier: inputs
          ): )
          compound_statement: {
      (*signature_def.mutable_inputs())[input].set_name(input);
    }
           {: {
           expression_statement: (*signature_def.mutable_inputs())[input].set_name(input);
            call_expression: (*signature_def.mutable_inputs())[input].set_name(input)
             field_expression: (*signature_def.mutable_inputs())[input].set_name
              subscript_expression: (*signature_def.mutable_inputs())[input]
               parenthesized_expression: (*signature_def.mutable_inputs())
                (: (
                pointer_expression: *signature_def.mutable_inputs()
                 *: *
                 call_expression: signature_def.mutable_inputs()
                  field_expression: signature_def.mutable_inputs
                   identifier: signature_def
                   .: .
                   field_identifier: mutable_inputs
                  argument_list: ()
                   (: (
                   ): )
                ): )
               subscript_argument_list: [input]
                [: [
                identifier: input
                ]: ]
              .: .
              field_identifier: set_name
             argument_list: (input)
              (: (
              identifier: input
              ): )
            ;: ;
           }: }
         for_range_loop: for (const string& output : outputs) {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
          for: for
          (: (
          type_qualifier: const
           const: const
          type_identifier: string
          reference_declarator: & output
           &: &
           identifier: output
          :: :
          identifier: outputs
          ): )
          compound_statement: {
      (*signature_def.mutable_outputs())[output].set_name(output);
    }
           {: {
           expression_statement: (*signature_def.mutable_outputs())[output].set_name(output);
            call_expression: (*signature_def.mutable_outputs())[output].set_name(output)
             field_expression: (*signature_def.mutable_outputs())[output].set_name
              subscript_expression: (*signature_def.mutable_outputs())[output]
               parenthesized_expression: (*signature_def.mutable_outputs())
                (: (
                pointer_expression: *signature_def.mutable_outputs()
                 *: *
                 call_expression: signature_def.mutable_outputs()
                  field_expression: signature_def.mutable_outputs
                   identifier: signature_def
                   .: .
                   field_identifier: mutable_outputs
                  argument_list: ()
                   (: (
                   ): )
                ): )
               subscript_argument_list: [output]
                [: [
                identifier: output
                ]: ]
              .: .
              field_identifier: set_name
             argument_list: (output)
              (: (
              identifier: output
              ): )
            ;: ;
           }: }
         return_statement: return signature_def;
          return: return
          identifier: signature_def
          ;: ;
         }: }
       comment: // Adds `signature_def` to `saved_model_bundle` under `key`.
       function_definition: void AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }
        primitive_type: void
        function_declarator: AddSignatureDefToSavedModelBundle(const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle)
         field_identifier: AddSignatureDefToSavedModelBundle
         parameter_list: (const SignatureDef& signature_def,
                                         const string& key,
                                         SavedModelBundle* saved_model_bundle)
          (: (
          parameter_declaration: const SignatureDef& signature_def
           type_qualifier: const
            const: const
           type_identifier: SignatureDef
           reference_declarator: & signature_def
            &: &
            identifier: signature_def
          ,: ,
          parameter_declaration: const string& key
           type_qualifier: const
            const: const
           type_identifier: string
           reference_declarator: & key
            &: &
            identifier: key
          ,: ,
          parameter_declaration: SavedModelBundle* saved_model_bundle
           type_identifier: SavedModelBundle
           pointer_declarator: * saved_model_bundle
            *: *
            identifier: saved_model_bundle
          ): )
        compound_statement: {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    (*meta_graph_def->mutable_signature_def())[key] = signature_def;
  }
         {: {
         declaration: MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
          type_identifier: MetaGraphDef
          init_declarator: * meta_graph_def = &saved_model_bundle->meta_graph_def
           pointer_declarator: * meta_graph_def
            *: *
            identifier: meta_graph_def
           =: =
           pointer_expression: &saved_model_bundle->meta_graph_def
            &: &
            field_expression: saved_model_bundle->meta_graph_def
             identifier: saved_model_bundle
             ->: ->
             field_identifier: meta_graph_def
          ;: ;
         expression_statement: (*meta_graph_def->mutable_signature_def())[key] = signature_def;
          assignment_expression: (*meta_graph_def->mutable_signature_def())[key] = signature_def
           subscript_expression: (*meta_graph_def->mutable_signature_def())[key]
            parenthesized_expression: (*meta_graph_def->mutable_signature_def())
             (: (
             pointer_expression: *meta_graph_def->mutable_signature_def()
              *: *
              call_expression: meta_graph_def->mutable_signature_def()
               field_expression: meta_graph_def->mutable_signature_def
                identifier: meta_graph_def
                ->: ->
                field_identifier: mutable_signature_def
               argument_list: ()
                (: (
                ): )
             ): )
            subscript_argument_list: [key]
             [: [
             identifier: key
             ]: ]
           =: =
           identifier: signature_def
          ;: ;
         }: }
       comment: // Adds an initialized session to `saved_model_bundle` using `graph_def` and
       comment: // initializing with `init_node`.
       function_definition: absl::Status InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }
        qualified_identifier: absl::Status
         namespace_identifier: absl
         ::: ::
         type_identifier: Status
        function_declarator: InitializeSavedModelBundleSession(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle)
         field_identifier: InitializeSavedModelBundleSession
         parameter_list: (
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle)
          (: (
          parameter_declaration: const GraphDef& graph_def
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & graph_def
            &: &
            identifier: graph_def
          ,: ,
          parameter_declaration: const string& init_node
           type_qualifier: const
            const: const
           type_identifier: string
           reference_declarator: & init_node
            &: &
            identifier: init_node
          ,: ,
          parameter_declaration: SavedModelBundle* saved_model_bundle
           type_identifier: SavedModelBundle
           pointer_declarator: * saved_model_bundle
            *: *
            identifier: saved_model_bundle
          ): )
        compound_statement: {
    SessionOptions session_options;
    saved_model_bundle->session.reset(NewSession(session_options));
    TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
    if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
    return absl::OkStatus();
  }
         {: {
         declaration: SessionOptions session_options;
          type_identifier: SessionOptions
          identifier: session_options
          ;: ;
         expression_statement: saved_model_bundle->session.reset(NewSession(session_options));
          call_expression: saved_model_bundle->session.reset(NewSession(session_options))
           field_expression: saved_model_bundle->session.reset
            field_expression: saved_model_bundle->session
             identifier: saved_model_bundle
             ->: ->
             field_identifier: session
            .: .
            field_identifier: reset
           argument_list: (NewSession(session_options))
            (: (
            call_expression: NewSession(session_options)
             identifier: NewSession
             argument_list: (session_options)
              (: (
              identifier: session_options
              ): )
            ): )
          ;: ;
         expression_statement: TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def));
          call_expression: TF_RETURN_IF_ERROR(saved_model_bundle->session->Create(graph_def))
           identifier: TF_RETURN_IF_ERROR
           argument_list: (saved_model_bundle->session->Create(graph_def))
            (: (
            call_expression: saved_model_bundle->session->Create(graph_def)
             field_expression: saved_model_bundle->session->Create
              field_expression: saved_model_bundle->session
               identifier: saved_model_bundle
               ->: ->
               field_identifier: session
              ->: ->
              field_identifier: Create
             argument_list: (graph_def)
              (: (
              identifier: graph_def
              ): )
            ): )
          ;: ;
         if_statement: if (!init_node.empty()) {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
          if: if
          condition_clause: (!init_node.empty())
           (: (
           unary_expression: !init_node.empty()
            !: !
            call_expression: init_node.empty()
             field_expression: init_node.empty
              identifier: init_node
              .: .
              field_identifier: empty
             argument_list: ()
              (: (
              ): )
           ): )
          compound_statement: {
      std::vector<Tensor> outputs;
      return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
    }
           {: {
           declaration: std::vector<Tensor> outputs;
            qualified_identifier: std::vector<Tensor>
             namespace_identifier: std
             ::: ::
             template_type: vector<Tensor>
              type_identifier: vector
              template_argument_list: <Tensor>
               <: <
               type_descriptor: Tensor
                type_identifier: Tensor
               >: >
            identifier: outputs
            ;: ;
           return_statement: return saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs);
            return: return
            call_expression: saved_model_bundle->session->Run(
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs)
             field_expression: saved_model_bundle->session->Run
              field_expression: saved_model_bundle->session
               identifier: saved_model_bundle
               ->: ->
               field_identifier: session
              ->: ->
              field_identifier: Run
             argument_list: (
          /* inputs */ {}, /* output_tensors */ {}, {init_node}, &outputs)
              (: (
              comment: /* inputs */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              comment: /* output_tensors */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              initializer_list: {init_node}
               {: {
               identifier: init_node
               }: }
              ,: ,
              pointer_expression: &outputs
               &: &
               identifier: outputs
              ): )
            ;: ;
           }: }
         return_statement: return absl::OkStatus();
          return: return
          call_expression: absl::OkStatus()
           qualified_identifier: absl::OkStatus
            namespace_identifier: absl
            ::: ::
            identifier: OkStatus
           argument_list: ()
            (: (
            ): )
          ;: ;
         }: }
       comment: // Adds `graph_def` to `saved_model_bundle` and initializes a session with
       comment: // `init_node`.
       function_definition: absl::Status AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle) {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }
        qualified_identifier: absl::Status
         namespace_identifier: absl
         ::: ::
         type_identifier: Status
        function_declarator: AddGraphDefToSavedModelBundle(
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle)
         field_identifier: AddGraphDefToSavedModelBundle
         parameter_list: (
      const GraphDef& graph_def, const string& init_node,
      SavedModelBundle* saved_model_bundle)
          (: (
          parameter_declaration: const GraphDef& graph_def
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & graph_def
            &: &
            identifier: graph_def
          ,: ,
          parameter_declaration: const string& init_node
           type_qualifier: const
            const: const
           type_identifier: string
           reference_declarator: & init_node
            &: &
            identifier: init_node
          ,: ,
          parameter_declaration: SavedModelBundle* saved_model_bundle
           type_identifier: SavedModelBundle
           pointer_declarator: * saved_model_bundle
            *: *
            identifier: saved_model_bundle
          ): )
        compound_statement: {
    MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
    *meta_graph_def->mutable_graph_def() = graph_def;
    return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
  }
         {: {
         declaration: MetaGraphDef* meta_graph_def = &saved_model_bundle->meta_graph_def;
          type_identifier: MetaGraphDef
          init_declarator: * meta_graph_def = &saved_model_bundle->meta_graph_def
           pointer_declarator: * meta_graph_def
            *: *
            identifier: meta_graph_def
           =: =
           pointer_expression: &saved_model_bundle->meta_graph_def
            &: &
            field_expression: saved_model_bundle->meta_graph_def
             identifier: saved_model_bundle
             ->: ->
             field_identifier: meta_graph_def
          ;: ;
         expression_statement: *meta_graph_def->mutable_graph_def() = graph_def;
          assignment_expression: *meta_graph_def->mutable_graph_def() = graph_def
           pointer_expression: *meta_graph_def->mutable_graph_def()
            *: *
            call_expression: meta_graph_def->mutable_graph_def()
             field_expression: meta_graph_def->mutable_graph_def
              identifier: meta_graph_def
              ->: ->
              field_identifier: mutable_graph_def
             argument_list: ()
              (: (
              ): )
           =: =
           identifier: graph_def
          ;: ;
         return_statement: return InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle);
          return: return
          call_expression: InitializeSavedModelBundleSession(graph_def, init_node,
                                             saved_model_bundle)
           identifier: InitializeSavedModelBundleSession
           argument_list: (graph_def, init_node,
                                             saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            identifier: init_node
            ,: ,
            identifier: saved_model_bundle
            ): )
          ;: ;
         }: }
       comment: // Adds `graph_def` and `outputs` as the GraphDef and SignatureDef in
       comment: // `saved_model_bundle` and initializes a session with `init_node`.
       function_definition: absl::Status AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle) {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }
        qualified_identifier: absl::Status
         namespace_identifier: absl
         ::: ::
         type_identifier: Status
        function_declarator: AddGraphDefWithOutputsToSavedModelBundle(
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle)
         field_identifier: AddGraphDefWithOutputsToSavedModelBundle
         parameter_list: (
      const GraphDef& graph_def, const std::unordered_set<string>& outputs,
      const string& init_node, SavedModelBundle* saved_model_bundle)
          (: (
          parameter_declaration: const GraphDef& graph_def
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & graph_def
            &: &
            identifier: graph_def
          ,: ,
          parameter_declaration: const std::unordered_set<string>& outputs
           type_qualifier: const
            const: const
           qualified_identifier: std::unordered_set<string>
            namespace_identifier: std
            ::: ::
            template_type: unordered_set<string>
             type_identifier: unordered_set
             template_argument_list: <string>
              <: <
              type_descriptor: string
               type_identifier: string
              >: >
           reference_declarator: & outputs
            &: &
            identifier: outputs
          ,: ,
          parameter_declaration: const string& init_node
           type_qualifier: const
            const: const
           type_identifier: string
           reference_declarator: & init_node
            &: &
            identifier: init_node
          ,: ,
          parameter_declaration: SavedModelBundle* saved_model_bundle
           type_identifier: SavedModelBundle
           pointer_declarator: * saved_model_bundle
            *: *
            identifier: saved_model_bundle
          ): )
        compound_statement: {
    SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
    AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
    return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
  }
         {: {
         declaration: SignatureDef signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs);
          type_identifier: SignatureDef
          init_declarator: signature_def =
        BuildSignatureDef(std::unordered_set<string>(), outputs)
           identifier: signature_def
           =: =
           call_expression: BuildSignatureDef(std::unordered_set<string>(), outputs)
            identifier: BuildSignatureDef
            argument_list: (std::unordered_set<string>(), outputs)
             (: (
             call_expression: std::unordered_set<string>()
              qualified_identifier: std::unordered_set<string>
               namespace_identifier: std
               ::: ::
               template_function: unordered_set<string>
                identifier: unordered_set
                template_argument_list: <string>
                 <: <
                 type_descriptor: string
                  type_identifier: string
                 >: >
              argument_list: ()
               (: (
               ): )
             ,: ,
             identifier: outputs
             ): )
          ;: ;
         expression_statement: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle);
          call_expression: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                      saved_model_bundle)
           identifier: AddSignatureDefToSavedModelBundle
           argument_list: (signature_def, "signature_def",
                                      saved_model_bundle)
            (: (
            identifier: signature_def
            ,: ,
            string_literal: "signature_def"
             ": "
             string_content: signature_def
             ": "
            ,: ,
            identifier: saved_model_bundle
            ): )
          ;: ;
         return_statement: return AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle);
          return: return
          call_expression: AddGraphDefToSavedModelBundle(graph_def, init_node,
                                         saved_model_bundle)
           identifier: AddGraphDefToSavedModelBundle
           argument_list: (graph_def, init_node,
                                         saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            identifier: init_node
            ,: ,
            identifier: saved_model_bundle
            ): )
          ;: ;
         }: }
       comment: // Runs and compares the outputs of `tensor_name` on both the
       comment: // `unfrozen_session` and the `frozen_graph_def.
       function_definition: void RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name) {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }
        primitive_type: void
        function_declarator: RunAndCompareFrozenAndUnfrozenGraphs(Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name)
         field_identifier: RunAndCompareFrozenAndUnfrozenGraphs
         parameter_list: (Session* unfrozen_session,
                                            const GraphDef& frozen_graph_def,
                                            const string& tensor_name)
          (: (
          parameter_declaration: Session* unfrozen_session
           type_identifier: Session
           pointer_declarator: * unfrozen_session
            *: *
            identifier: unfrozen_session
          ,: ,
          parameter_declaration: const GraphDef& frozen_graph_def
           type_qualifier: const
            const: const
           type_identifier: GraphDef
           reference_declarator: & frozen_graph_def
            &: &
            identifier: frozen_graph_def
          ,: ,
          parameter_declaration: const string& tensor_name
           type_qualifier: const
            const: const
           type_identifier: string
           reference_declarator: & tensor_name
            &: &
            identifier: tensor_name
          ): )
        compound_statement: {
    std::vector<Tensor> unfrozen_outputs;
    TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));

    SessionOptions session_options;
    std::unique_ptr<Session> frozen_session(NewSession(session_options));
    TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
    std::vector<Tensor> frozen_outputs;
    TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));

    test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
  }
         {: {
         declaration: std::vector<Tensor> unfrozen_outputs;
          qualified_identifier: std::vector<Tensor>
           namespace_identifier: std
           ::: ::
           template_type: vector<Tensor>
            type_identifier: vector
            template_argument_list: <Tensor>
             <: <
             type_descriptor: Tensor
              type_identifier: Tensor
             >: >
          identifier: unfrozen_outputs
          ;: ;
         expression_statement: TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs));
          call_expression: TF_ASSERT_OK(unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs))
           identifier: TF_ASSERT_OK
           argument_list: (unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs))
            (: (
            call_expression: unfrozen_session->Run(/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs)
             field_expression: unfrozen_session->Run
              identifier: unfrozen_session
              ->: ->
              field_identifier: Run
             argument_list: (/* inputs */ {}, {tensor_name},
                                       /* targets */ {}, &unfrozen_outputs)
              (: (
              comment: /* inputs */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              initializer_list: {tensor_name}
               {: {
               identifier: tensor_name
               }: }
              ,: ,
              comment: /* targets */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              pointer_expression: &unfrozen_outputs
               &: &
               identifier: unfrozen_outputs
              ): )
            ): )
          ;: ;
         declaration: SessionOptions session_options;
          type_identifier: SessionOptions
          identifier: session_options
          ;: ;
         declaration: std::unique_ptr<Session> frozen_session(NewSession(session_options));
          qualified_identifier: std::unique_ptr<Session>
           namespace_identifier: std
           ::: ::
           template_type: unique_ptr<Session>
            type_identifier: unique_ptr
            template_argument_list: <Session>
             <: <
             type_descriptor: Session
              type_identifier: Session
             >: >
          function_declarator: frozen_session(NewSession(session_options))
           identifier: frozen_session
           parameter_list: (NewSession(session_options))
            (: (
            parameter_declaration: NewSession(session_options)
             type_identifier: NewSession
             abstract_function_declarator: (session_options)
              parameter_list: (session_options)
               (: (
               parameter_declaration: session_options
                type_identifier: session_options
               ): )
            ): )
          ;: ;
         expression_statement: TF_ASSERT_OK(frozen_session->Create(frozen_graph_def));
          call_expression: TF_ASSERT_OK(frozen_session->Create(frozen_graph_def))
           identifier: TF_ASSERT_OK
           argument_list: (frozen_session->Create(frozen_graph_def))
            (: (
            call_expression: frozen_session->Create(frozen_graph_def)
             field_expression: frozen_session->Create
              identifier: frozen_session
              ->: ->
              field_identifier: Create
             argument_list: (frozen_graph_def)
              (: (
              identifier: frozen_graph_def
              ): )
            ): )
          ;: ;
         declaration: std::vector<Tensor> frozen_outputs;
          qualified_identifier: std::vector<Tensor>
           namespace_identifier: std
           ::: ::
           template_type: vector<Tensor>
            type_identifier: vector
            template_argument_list: <Tensor>
             <: <
             type_descriptor: Tensor
              type_identifier: Tensor
             >: >
          identifier: frozen_outputs
          ;: ;
         expression_statement: TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs));
          call_expression: TF_ASSERT_OK(frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs))
           identifier: TF_ASSERT_OK
           argument_list: (frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs))
            (: (
            call_expression: frozen_session->Run(/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs)
             field_expression: frozen_session->Run
              identifier: frozen_session
              ->: ->
              field_identifier: Run
             argument_list: (/* inputs */ {}, {tensor_name},
                                     /* targets */ {}, &frozen_outputs)
              (: (
              comment: /* inputs */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              initializer_list: {tensor_name}
               {: {
               identifier: tensor_name
               }: }
              ,: ,
              comment: /* targets */
              initializer_list: {}
               {: {
               }: }
              ,: ,
              pointer_expression: &frozen_outputs
               &: &
               identifier: frozen_outputs
              ): )
            ): )
          ;: ;
         expression_statement: test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0]);
          call_expression: test::ExpectTensorEqual<float>(unfrozen_outputs[0], frozen_outputs[0])
           qualified_identifier: test::ExpectTensorEqual<float>
            namespace_identifier: test
            ::: ::
            template_function: ExpectTensorEqual<float>
             identifier: ExpectTensorEqual
             template_argument_list: <float>
              <: <
              type_descriptor: float
               primitive_type: float
              >: >
           argument_list: (unfrozen_outputs[0], frozen_outputs[0])
            (: (
            subscript_expression: unfrozen_outputs[0]
             identifier: unfrozen_outputs
             subscript_argument_list: [0]
              [: [
              number_literal: 0
              ]: ]
            ,: ,
            subscript_expression: frozen_outputs[0]
             identifier: frozen_outputs
             subscript_argument_list: [0]
              [: [
              number_literal: 0
              ]: ]
            ): )
          ;: ;
         }: }
       function_definition: void TestFreezeGraphWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
        primitive_type: void
        function_declarator: TestFreezeGraphWithoutDependentVariables(bool use_resource)
         field_identifier: TestFreezeGraphWithoutDependentVariables
         parameter_list: (bool use_resource)
          (: (
          parameter_declaration: bool use_resource
           primitive_type: bool
           identifier: use_resource
          ): )
        compound_statement: {
    // Test freezing a graph with variables that are not needed by the outputs
    // in the SignatureDef. The resulting graph shouldn't be frozen, but
    // non-dependent nodes should be pruned.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
    Output c = ops::Mul(scope.WithOpName("c"), a, b);
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }

    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    GraphDef expected_graph_def;
    Scope expected_scope = Scope::NewRootScope();
    Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
    Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
    Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
    TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));

    GraphDefEqual(frozen_graph_def, expected_graph_def);

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
         {: {
         comment: // Test freezing a graph with variables that are not needed by the outputs
         comment: // in the SignatureDef. The resulting graph shouldn't be frozen, but
         comment: // non-dependent nodes should be pruned.
         declaration: SavedModelBundle saved_model_bundle;
          type_identifier: SavedModelBundle
          identifier: saved_model_bundle
          ;: ;
         declaration: GraphDef graph_def;
          type_identifier: GraphDef
          identifier: graph_def
          ;: ;
         declaration: Scope scope = Scope::NewRootScope();
          type_identifier: Scope
          init_declarator: scope = Scope::NewRootScope()
           identifier: scope
           =: =
           call_expression: Scope::NewRootScope()
            qualified_identifier: Scope::NewRootScope
             namespace_identifier: Scope
             ::: ::
             identifier: NewRootScope
            argument_list: ()
             (: (
             ): )
          ;: ;
         declaration: Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
          type_identifier: Output
          init_declarator: a = ops::Const(scope.WithOpName("a"), 10.0f, {})
           identifier: a
           =: =
           call_expression: ops::Const(scope.WithOpName("a"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (scope.WithOpName("a"), 10.0f, {})
             (: (
             call_expression: scope.WithOpName("a")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("a")
               (: (
               string_literal: "a"
                ": "
                string_content: a
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
          type_identifier: Output
          init_declarator: b = ops::Const(scope.WithOpName("b"), 10.0f, {})
           identifier: b
           =: =
           call_expression: ops::Const(scope.WithOpName("b"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (scope.WithOpName("b"), 10.0f, {})
             (: (
             call_expression: scope.WithOpName("b")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("b")
               (: (
               string_literal: "b"
                ": "
                string_content: b
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output c = ops::Mul(scope.WithOpName("c"), a, b);
          type_identifier: Output
          init_declarator: c = ops::Mul(scope.WithOpName("c"), a, b)
           identifier: c
           =: =
           call_expression: ops::Mul(scope.WithOpName("c"), a, b)
            qualified_identifier: ops::Mul
             namespace_identifier: ops
             ::: ::
             identifier: Mul
            argument_list: (scope.WithOpName("c"), a, b)
             (: (
             call_expression: scope.WithOpName("c")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("c")
               (: (
               string_literal: "c"
                ": "
                string_content: c
                ": "
               ): )
             ,: ,
             identifier: a
             ,: ,
             identifier: b
             ): )
          ;: ;
         if_statement: if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }
          if: if
          condition_clause: (use_resource)
           (: (
           identifier: use_resource
           ): )
          compound_statement: {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    }
           {: {
           declaration: Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
            type_identifier: Output
            init_declarator: var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
             identifier: var
             =: =
             call_expression: ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
              qualified_identifier: ops::VarHandleOp
               namespace_identifier: ops
               ::: ::
               identifier: VarHandleOp
              argument_list: (scope.WithOpName("var"), DataType::DT_FLOAT, {})
               (: (
               call_expression: scope.WithOpName("var")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var")
                 (: (
                 string_literal: "var"
                  ": "
                  string_content: var
                  ": "
                 ): )
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ,: ,
               initializer_list: {}
                {: {
                }: }
               ): )
            ;: ;
           declaration: Output read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
            type_identifier: Output
            init_declarator: read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
             identifier: read_var
             =: =
             call_expression: ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
              qualified_identifier: ops::ReadVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: ReadVariableOp
              argument_list: (
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
               (: (
               call_expression: scope.WithOpName("var/Read/ReadVariableOp")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var/Read/ReadVariableOp")
                 (: (
                 string_literal: "var/Read/ReadVariableOp"
                  ": "
                  string_content: var/Read/ReadVariableOp
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ): )
            ;: ;
           declaration: auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
            placeholder_type_specifier: auto
             auto: auto
            init_declarator: assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
             identifier: assign
             =: =
             call_expression: ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
              qualified_identifier: ops::AssignVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: AssignVariableOp
              argument_list: (scope.WithOpName("assign"), var, a)
               (: (
               call_expression: scope.WithOpName("assign")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("assign")
                 (: (
                 string_literal: "assign"
                  ": "
                  string_content: assign
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               identifier: a
               ): )
            ;: ;
           }: }
          else_clause: else {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }
           else: else
           compound_statement: {
      Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
    }
            {: {
            declaration: Output var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
             type_identifier: Output
             init_declarator: var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
              identifier: var
              =: =
              call_expression: ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
               qualified_identifier: ops::Variable
                namespace_identifier: ops
                ::: ::
                identifier: Variable
               argument_list: (scope.WithOpName("var"), {}, DataType::DT_FLOAT)
                (: (
                call_expression: scope.WithOpName("var")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("var")
                  (: (
                  string_literal: "var"
                   ": "
                   string_content: var
                   ": "
                  ): )
                ,: ,
                initializer_list: {}
                 {: {
                 }: }
                ,: ,
                qualified_identifier: DataType::DT_FLOAT
                 namespace_identifier: DataType
                 ::: ::
                 identifier: DT_FLOAT
                ): )
             ;: ;
            declaration: Output assign = ops::Assign(scope.WithOpName("assign"), var, a);
             type_identifier: Output
             init_declarator: assign = ops::Assign(scope.WithOpName("assign"), var, a)
              identifier: assign
              =: =
              call_expression: ops::Assign(scope.WithOpName("assign"), var, a)
               qualified_identifier: ops::Assign
                namespace_identifier: ops
                ::: ::
                identifier: Assign
               argument_list: (scope.WithOpName("assign"), var, a)
                (: (
                call_expression: scope.WithOpName("assign")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("assign")
                  (: (
                  string_literal: "assign"
                   ": "
                   string_content: assign
                   ": "
                  ): )
                ,: ,
                identifier: var
                ,: ,
                identifier: a
                ): )
             ;: ;
            }: }
         expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
          call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
           identifier: TF_ASSERT_OK
           argument_list: (scope.ToGraphDef(&graph_def))
            (: (
            call_expression: scope.ToGraphDef(&graph_def)
             field_expression: scope.ToGraphDef
              identifier: scope
              .: .
              field_identifier: ToGraphDef
             argument_list: (&graph_def)
              (: (
              pointer_expression: &graph_def
               &: &
               identifier: graph_def
              ): )
            ): )
          ;: ;
         comment: // "c" isn't dependent on the variable, so nothing should be frozen.
         expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));
          call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
           identifier: TF_ASSERT_OK
           argument_list: (AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
            (: (
            call_expression: AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
             identifier: AddGraphDefWithOutputsToSavedModelBundle
             argument_list: (
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
              (: (
              identifier: graph_def
              ,: ,
              initializer_list: {"c:0"}
               {: {
               string_literal: "c:0"
                ": "
                string_content: c:0
                ": "
               }: }
              ,: ,
              string_literal: "assign"
               ": "
               string_content: assign
               ": "
              ,: ,
              pointer_expression: &saved_model_bundle
               &: &
               identifier: saved_model_bundle
              ): )
            ): )
          ;: ;
         declaration: GraphDef frozen_graph_def;
          type_identifier: GraphDef
          identifier: frozen_graph_def
          ;: ;
         declaration: std::unordered_set<string> inputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: inputs
          ;: ;
         declaration: std::unordered_set<string> outputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: outputs
          ;: ;
         expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));
          call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
           identifier: TF_ASSERT_OK
           argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
            (: (
            call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
             identifier: FreezeSavedModel
             argument_list: (saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
              (: (
              identifier: saved_model_bundle
              ,: ,
              pointer_expression: &frozen_graph_def
               &: &
               identifier: frozen_graph_def
              ,: ,
              pointer_expression: &inputs
               &: &
               identifier: inputs
              ,: ,
              pointer_expression: &outputs
               &: &
               identifier: outputs
              ): )
            ): )
          ;: ;
         declaration: GraphDef expected_graph_def;
          type_identifier: GraphDef
          identifier: expected_graph_def
          ;: ;
         declaration: Scope expected_scope = Scope::NewRootScope();
          type_identifier: Scope
          init_declarator: expected_scope = Scope::NewRootScope()
           identifier: expected_scope
           =: =
           call_expression: Scope::NewRootScope()
            qualified_identifier: Scope::NewRootScope
             namespace_identifier: Scope
             ::: ::
             identifier: NewRootScope
            argument_list: ()
             (: (
             ): )
          ;: ;
         declaration: Output expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {});
          type_identifier: Output
          init_declarator: expected_a = ops::Const(expected_scope.WithOpName("a"), 10.0f, {})
           identifier: expected_a
           =: =
           call_expression: ops::Const(expected_scope.WithOpName("a"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (expected_scope.WithOpName("a"), 10.0f, {})
             (: (
             call_expression: expected_scope.WithOpName("a")
              field_expression: expected_scope.WithOpName
               identifier: expected_scope
               .: .
               field_identifier: WithOpName
              argument_list: ("a")
               (: (
               string_literal: "a"
                ": "
                string_content: a
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {});
          type_identifier: Output
          init_declarator: expected_b = ops::Const(expected_scope.WithOpName("b"), 10.0f, {})
           identifier: expected_b
           =: =
           call_expression: ops::Const(expected_scope.WithOpName("b"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (expected_scope.WithOpName("b"), 10.0f, {})
             (: (
             call_expression: expected_scope.WithOpName("b")
              field_expression: expected_scope.WithOpName
               identifier: expected_scope
               .: .
               field_identifier: WithOpName
              argument_list: ("b")
               (: (
               string_literal: "b"
                ": "
                string_content: b
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b);
          type_identifier: Output
          init_declarator: expected_c =
        ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b)
           identifier: expected_c
           =: =
           call_expression: ops::Mul(expected_scope.WithOpName("c"), expected_a, expected_b)
            qualified_identifier: ops::Mul
             namespace_identifier: ops
             ::: ::
             identifier: Mul
            argument_list: (expected_scope.WithOpName("c"), expected_a, expected_b)
             (: (
             call_expression: expected_scope.WithOpName("c")
              field_expression: expected_scope.WithOpName
               identifier: expected_scope
               .: .
               field_identifier: WithOpName
              argument_list: ("c")
               (: (
               string_literal: "c"
                ": "
                string_content: c
                ": "
               ): )
             ,: ,
             identifier: expected_a
             ,: ,
             identifier: expected_b
             ): )
          ;: ;
         expression_statement: TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def));
          call_expression: TF_ASSERT_OK(expected_scope.ToGraphDef(&expected_graph_def))
           identifier: TF_ASSERT_OK
           argument_list: (expected_scope.ToGraphDef(&expected_graph_def))
            (: (
            call_expression: expected_scope.ToGraphDef(&expected_graph_def)
             field_expression: expected_scope.ToGraphDef
              identifier: expected_scope
              .: .
              field_identifier: ToGraphDef
             argument_list: (&expected_graph_def)
              (: (
              pointer_expression: &expected_graph_def
               &: &
               identifier: expected_graph_def
              ): )
            ): )
          ;: ;
         expression_statement: GraphDefEqual(frozen_graph_def, expected_graph_def);
          call_expression: GraphDefEqual(frozen_graph_def, expected_graph_def)
           identifier: GraphDefEqual
           argument_list: (frozen_graph_def, expected_graph_def)
            (: (
            identifier: frozen_graph_def
            ,: ,
            identifier: expected_graph_def
            ): )
          ;: ;
         expression_statement: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
          call_expression: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
           identifier: RunAndCompareFrozenAndUnfrozenGraphs
           argument_list: (saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
            (: (
            call_expression: saved_model_bundle.session.get()
             field_expression: saved_model_bundle.session.get
              field_expression: saved_model_bundle.session
               identifier: saved_model_bundle
               .: .
               field_identifier: session
              .: .
              field_identifier: get
             argument_list: ()
              (: (
              ): )
            ,: ,
            identifier: frozen_graph_def
            ,: ,
            string_literal: "c:0"
             ": "
             string_content: c:0
             ": "
            ): )
          ;: ;
         }: }
       function_definition: void TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false) {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
        primitive_type: void
        function_declarator: TestFreezeGraphWithDependentVariables(bool use_resource,
                                             bool use_identity = false)
         field_identifier: TestFreezeGraphWithDependentVariables
         parameter_list: (bool use_resource,
                                             bool use_identity = false)
          (: (
          parameter_declaration: bool use_resource
           primitive_type: bool
           identifier: use_resource
          ,: ,
          optional_parameter_declaration: bool use_identity = false
           primitive_type: bool
           identifier: use_identity
           =: =
           false: false
          ): )
        compound_statement: {
    // Test freezing a graph with variables that are needed by outputs in the
    // SignatureDef. The variables should be frozen.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;
    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // If using normal variables there should be 3 nodes in the resulting
    // graph_def. If using resource variables there should be 4 nodes in the
    // resulting graph_def if use_identity == false, otherwise 5 variables.
    // In both cases, none should be variables.
    size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;

    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
         {: {
         comment: // Test freezing a graph with variables that are needed by outputs in the
         comment: // SignatureDef. The variables should be frozen.
         declaration: SavedModelBundle saved_model_bundle;
          type_identifier: SavedModelBundle
          identifier: saved_model_bundle
          ;: ;
         declaration: GraphDef graph_def;
          type_identifier: GraphDef
          identifier: graph_def
          ;: ;
         declaration: Scope scope = Scope::NewRootScope();
          type_identifier: Scope
          init_declarator: scope = Scope::NewRootScope()
           identifier: scope
           =: =
           call_expression: Scope::NewRootScope()
            qualified_identifier: Scope::NewRootScope
             namespace_identifier: Scope
             ::: ::
             identifier: NewRootScope
            argument_list: ()
             (: (
             ): )
          ;: ;
         declaration: Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
          type_identifier: Output
          init_declarator: a = ops::Const(scope.WithOpName("a"), 10.0f, {})
           identifier: a
           =: =
           call_expression: ops::Const(scope.WithOpName("a"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (scope.WithOpName("a"), 10.0f, {})
             (: (
             call_expression: scope.WithOpName("a")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("a")
               (: (
               string_literal: "a"
                ": "
                string_content: a
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output read_var;
          type_identifier: Output
          identifier: read_var
          ;: ;
         if_statement: if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    } else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
          if: if
          condition_clause: (use_resource)
           (: (
           identifier: use_resource
           ): )
          compound_statement: {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
    }
           {: {
           declaration: Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
            type_identifier: Output
            init_declarator: var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
             identifier: var
             =: =
             call_expression: ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
              qualified_identifier: ops::VarHandleOp
               namespace_identifier: ops
               ::: ::
               identifier: VarHandleOp
              argument_list: (scope.WithOpName("var"), DataType::DT_FLOAT, {})
               (: (
               call_expression: scope.WithOpName("var")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var")
                 (: (
                 string_literal: "var"
                  ": "
                  string_content: var
                  ": "
                 ): )
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ,: ,
               initializer_list: {}
                {: {
                }: }
               ): )
            ;: ;
           if_statement: if (use_identity) {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      } else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
            if: if
            condition_clause: (use_identity)
             (: (
             identifier: use_identity
             ): )
            compound_statement: {
        Output identity = ops::Identity(scope.WithOpName("identity"), var);
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
      }
             {: {
             declaration: Output identity = ops::Identity(scope.WithOpName("identity"), var);
              type_identifier: Output
              init_declarator: identity = ops::Identity(scope.WithOpName("identity"), var)
               identifier: identity
               =: =
               call_expression: ops::Identity(scope.WithOpName("identity"), var)
                qualified_identifier: ops::Identity
                 namespace_identifier: ops
                 ::: ::
                 identifier: Identity
                argument_list: (scope.WithOpName("identity"), var)
                 (: (
                 call_expression: scope.WithOpName("identity")
                  field_expression: scope.WithOpName
                   identifier: scope
                   .: .
                   field_identifier: WithOpName
                  argument_list: ("identity")
                   (: (
                   string_literal: "identity"
                    ": "
                    string_content: identity
                    ": "
                   ): )
                 ,: ,
                 identifier: var
                 ): )
              ;: ;
             expression_statement: read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT);
              assignment_expression: read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT)
               identifier: read_var
               =: =
               call_expression: ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT)
                qualified_identifier: ops::ReadVariableOp
                 namespace_identifier: ops
                 ::: ::
                 identifier: ReadVariableOp
                argument_list: (scope.WithOpName("var/Read/ReadVariableOp"),
                                identity, DataType::DT_FLOAT)
                 (: (
                 call_expression: scope.WithOpName("var/Read/ReadVariableOp")
                  field_expression: scope.WithOpName
                   identifier: scope
                   .: .
                   field_identifier: WithOpName
                  argument_list: ("var/Read/ReadVariableOp")
                   (: (
                   string_literal: "var/Read/ReadVariableOp"
                    ": "
                    string_content: var/Read/ReadVariableOp
                    ": "
                   ): )
                 ,: ,
                 identifier: identity
                 ,: ,
                 qualified_identifier: DataType::DT_FLOAT
                  namespace_identifier: DataType
                  ::: ::
                  identifier: DT_FLOAT
                 ): )
              ;: ;
             }: }
            else_clause: else {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
             else: else
             compound_statement: {
        read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
      }
              {: {
              expression_statement: read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT);
               assignment_expression: read_var =
            ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT)
                identifier: read_var
                =: =
                call_expression: ops::ReadVariableOp(scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT)
                 qualified_identifier: ops::ReadVariableOp
                  namespace_identifier: ops
                  ::: ::
                  identifier: ReadVariableOp
                 argument_list: (scope.WithOpName("var/Read/ReadVariableOp"),
                                var, DataType::DT_FLOAT)
                  (: (
                  call_expression: scope.WithOpName("var/Read/ReadVariableOp")
                   field_expression: scope.WithOpName
                    identifier: scope
                    .: .
                    field_identifier: WithOpName
                   argument_list: ("var/Read/ReadVariableOp")
                    (: (
                    string_literal: "var/Read/ReadVariableOp"
                     ": "
                     string_content: var/Read/ReadVariableOp
                     ": "
                    ): )
                  ,: ,
                  identifier: var
                  ,: ,
                  qualified_identifier: DataType::DT_FLOAT
                   namespace_identifier: DataType
                   ::: ::
                   identifier: DT_FLOAT
                  ): )
               ;: ;
              }: }
           declaration: auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
            placeholder_type_specifier: auto
             auto: auto
            init_declarator: assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
             identifier: assign
             =: =
             call_expression: ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
              qualified_identifier: ops::AssignVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: AssignVariableOp
              argument_list: (scope.WithOpName("assign"), var, a)
               (: (
               call_expression: scope.WithOpName("assign")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("assign")
                 (: (
                 string_literal: "assign"
                  ": "
                  string_content: assign
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               identifier: a
               ): )
            ;: ;
           }: }
          else_clause: else {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
           else: else
           compound_statement: {
      Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
    }
            {: {
            declaration: Output read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
             type_identifier: Output
             init_declarator: read_var =
          ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
              identifier: read_var
              =: =
              call_expression: ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
               qualified_identifier: ops::Variable
                namespace_identifier: ops
                ::: ::
                identifier: Variable
               argument_list: (scope.WithOpName("var"), {}, DataType::DT_FLOAT)
                (: (
                call_expression: scope.WithOpName("var")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("var")
                  (: (
                  string_literal: "var"
                   ": "
                   string_content: var
                   ": "
                  ): )
                ,: ,
                initializer_list: {}
                 {: {
                 }: }
                ,: ,
                qualified_identifier: DataType::DT_FLOAT
                 namespace_identifier: DataType
                 ::: ::
                 identifier: DT_FLOAT
                ): )
             ;: ;
            declaration: Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
             type_identifier: Output
             init_declarator: assign = ops::Assign(scope.WithOpName("assign"), read_var, a)
              identifier: assign
              =: =
              call_expression: ops::Assign(scope.WithOpName("assign"), read_var, a)
               qualified_identifier: ops::Assign
                namespace_identifier: ops
                ::: ::
                identifier: Assign
               argument_list: (scope.WithOpName("assign"), read_var, a)
                (: (
                call_expression: scope.WithOpName("assign")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("assign")
                  (: (
                  string_literal: "assign"
                   ": "
                   string_content: assign
                   ": "
                  ): )
                ,: ,
                identifier: read_var
                ,: ,
                identifier: a
                ): )
             ;: ;
            }: }
         declaration: Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
          type_identifier: Output
          init_declarator: c = ops::Mul(scope.WithOpName("c"), a, read_var)
           identifier: c
           =: =
           call_expression: ops::Mul(scope.WithOpName("c"), a, read_var)
            qualified_identifier: ops::Mul
             namespace_identifier: ops
             ::: ::
             identifier: Mul
            argument_list: (scope.WithOpName("c"), a, read_var)
             (: (
             call_expression: scope.WithOpName("c")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("c")
               (: (
               string_literal: "c"
                ": "
                string_content: c
                ": "
               ): )
             ,: ,
             identifier: a
             ,: ,
             identifier: read_var
             ): )
          ;: ;
         expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
          call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
           identifier: TF_ASSERT_OK
           argument_list: (scope.ToGraphDef(&graph_def))
            (: (
            call_expression: scope.ToGraphDef(&graph_def)
             field_expression: scope.ToGraphDef
              identifier: scope
              .: .
              field_identifier: ToGraphDef
             argument_list: (&graph_def)
              (: (
              pointer_expression: &graph_def
               &: &
               identifier: graph_def
              ): )
            ): )
          ;: ;
         comment: // "c" isn't dependent on the variable, so nothing should be frozen.
         expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));
          call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
           identifier: TF_ASSERT_OK
           argument_list: (AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
            (: (
            call_expression: AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
             identifier: AddGraphDefWithOutputsToSavedModelBundle
             argument_list: (
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
              (: (
              identifier: graph_def
              ,: ,
              initializer_list: {"c:0"}
               {: {
               string_literal: "c:0"
                ": "
                string_content: c:0
                ": "
               }: }
              ,: ,
              string_literal: "assign"
               ": "
               string_content: assign
               ": "
              ,: ,
              pointer_expression: &saved_model_bundle
               &: &
               identifier: saved_model_bundle
              ): )
            ): )
          ;: ;
         declaration: GraphDef frozen_graph_def;
          type_identifier: GraphDef
          identifier: frozen_graph_def
          ;: ;
         declaration: std::unordered_set<string> inputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: inputs
          ;: ;
         declaration: std::unordered_set<string> outputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: outputs
          ;: ;
         expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));
          call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
           identifier: TF_ASSERT_OK
           argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
            (: (
            call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
             identifier: FreezeSavedModel
             argument_list: (saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
              (: (
              identifier: saved_model_bundle
              ,: ,
              pointer_expression: &frozen_graph_def
               &: &
               identifier: frozen_graph_def
              ,: ,
              pointer_expression: &inputs
               &: &
               identifier: inputs
              ,: ,
              pointer_expression: &outputs
               &: &
               identifier: outputs
              ): )
            ): )
          ;: ;
         comment: // If using normal variables there should be 3 nodes in the resulting
         comment: // graph_def. If using resource variables there should be 4 nodes in the
         comment: // resulting graph_def if use_identity == false, otherwise 5 variables.
         comment: // In both cases, none should be variables.
         declaration: size_t expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3;
          primitive_type: size_t
          init_declarator: expected_nodes = use_resource ? (use_identity ? 5 : 4) : 3
           identifier: expected_nodes
           =: =
           conditional_expression: use_resource ? (use_identity ? 5 : 4) : 3
            identifier: use_resource
            ?: ?
            parenthesized_expression: (use_identity ? 5 : 4)
             (: (
             conditional_expression: use_identity ? 5 : 4
              identifier: use_identity
              ?: ?
              number_literal: 5
              :: :
              number_literal: 4
             ): )
            :: :
            number_literal: 3
          ;: ;
         expression_statement: EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
          call_expression: EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes)
           identifier: EXPECT_EQ
           argument_list: (frozen_graph_def.node_size(), expected_nodes)
            (: (
            call_expression: frozen_graph_def.node_size()
             field_expression: frozen_graph_def.node_size
              identifier: frozen_graph_def
              .: .
              field_identifier: node_size
             argument_list: ()
              (: (
              ): )
            ,: ,
            identifier: expected_nodes
            ): )
          ;: ;
         for_range_loop: for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }
          for: for
          (: (
          type_qualifier: const
           const: const
          type_identifier: NodeDef
          reference_declarator: & node
           &: &
           identifier: node
          :: :
          call_expression: frozen_graph_def.node()
           field_expression: frozen_graph_def.node
            identifier: frozen_graph_def
            .: .
            field_identifier: node
           argument_list: ()
            (: (
            ): )
          ): )
          compound_statement: {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }
           {: {
           expression_statement: EXPECT_NE(node.op(), "Variable") << node.name();
            binary_expression: EXPECT_NE(node.op(), "Variable") << node.name()
             call_expression: EXPECT_NE(node.op(), "Variable")
              identifier: EXPECT_NE
              argument_list: (node.op(), "Variable")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "Variable"
                ": "
                string_content: Variable
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "VariableV2") << node.name();
            binary_expression: EXPECT_NE(node.op(), "VariableV2") << node.name()
             call_expression: EXPECT_NE(node.op(), "VariableV2")
              identifier: EXPECT_NE
              argument_list: (node.op(), "VariableV2")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "VariableV2"
                ": "
                string_content: VariableV2
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "VarHandleOp") << node.name();
            binary_expression: EXPECT_NE(node.op(), "VarHandleOp") << node.name()
             call_expression: EXPECT_NE(node.op(), "VarHandleOp")
              identifier: EXPECT_NE
              argument_list: (node.op(), "VarHandleOp")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "VarHandleOp"
                ": "
                string_content: VarHandleOp
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
            binary_expression: EXPECT_NE(node.op(), "ReadVariableOp") << node.name()
             call_expression: EXPECT_NE(node.op(), "ReadVariableOp")
              identifier: EXPECT_NE
              argument_list: (node.op(), "ReadVariableOp")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "ReadVariableOp"
                ": "
                string_content: ReadVariableOp
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           }: }
         expression_statement: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
          call_expression: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
           identifier: RunAndCompareFrozenAndUnfrozenGraphs
           argument_list: (saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
            (: (
            call_expression: saved_model_bundle.session.get()
             field_expression: saved_model_bundle.session.get
              field_expression: saved_model_bundle.session
               identifier: saved_model_bundle
               .: .
               field_identifier: session
              .: .
              field_identifier: get
             argument_list: ()
              (: (
              ): )
            ,: ,
            identifier: frozen_graph_def
            ,: ,
            string_literal: "c:0"
             ": "
             string_content: c:0
             ": "
            ): )
          ;: ;
         }: }
       function_definition: void TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource) {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
        primitive_type: void
        function_declarator: TestFreezeGraphWithAndWithoutDependentVariables(bool use_resource)
         field_identifier: TestFreezeGraphWithAndWithoutDependentVariables
         parameter_list: (bool use_resource)
          (: (
          parameter_declaration: bool use_resource
           primitive_type: bool
           identifier: use_resource
          ): )
        compound_statement: {
    // Test freezing a graph with some variables that are needed and not needed
    // by
    // the outputs in the SignatureDef. The resulting graph should only freeze
    // dependent variables.
    SavedModelBundle saved_model_bundle;
    GraphDef graph_def;
    Scope scope = Scope::NewRootScope();
    Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
    Output read_var;

    if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }

    Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
    TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
    // "c" isn't dependent on the variable, so nothing should be frozen.
    TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));

    GraphDef frozen_graph_def;
    std::unordered_set<string> inputs;
    std::unordered_set<string> outputs;
    TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));

    // There should be 3 nodes in the resulting graph_def, and none should be
    // variables.
    size_t expected_nodes = use_resource ? 4 : 3;
    EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
    for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }

    RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
  }
         {: {
         comment: // Test freezing a graph with some variables that are needed and not needed
         comment: // by
         comment: // the outputs in the SignatureDef. The resulting graph should only freeze
         comment: // dependent variables.
         declaration: SavedModelBundle saved_model_bundle;
          type_identifier: SavedModelBundle
          identifier: saved_model_bundle
          ;: ;
         declaration: GraphDef graph_def;
          type_identifier: GraphDef
          identifier: graph_def
          ;: ;
         declaration: Scope scope = Scope::NewRootScope();
          type_identifier: Scope
          init_declarator: scope = Scope::NewRootScope()
           identifier: scope
           =: =
           call_expression: Scope::NewRootScope()
            qualified_identifier: Scope::NewRootScope
             namespace_identifier: Scope
             ::: ::
             identifier: NewRootScope
            argument_list: ()
             (: (
             ): )
          ;: ;
         declaration: Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
          type_identifier: Output
          init_declarator: a = ops::Const(scope.WithOpName("a"), 10.0f, {})
           identifier: a
           =: =
           call_expression: ops::Const(scope.WithOpName("a"), 10.0f, {})
            qualified_identifier: ops::Const
             namespace_identifier: ops
             ::: ::
             identifier: Const
            argument_list: (scope.WithOpName("a"), 10.0f, {})
             (: (
             call_expression: scope.WithOpName("a")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("a")
               (: (
               string_literal: "a"
                ": "
                string_content: a
                ": "
               ): )
             ,: ,
             number_literal: 10.0f
             ,: ,
             initializer_list: {}
              {: {
              }: }
             ): )
          ;: ;
         declaration: Output read_var;
          type_identifier: Output
          identifier: read_var
          ;: ;
         if_statement: if (use_resource) {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    } else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }
          if: if
          condition_clause: (use_resource)
           (: (
           identifier: use_resource
           ): )
          compound_statement: {
      Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
      read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
      auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
      Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
      Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
      auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
    }
           {: {
           declaration: Output var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {});
            type_identifier: Output
            init_declarator: var =
          ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
             identifier: var
             =: =
             call_expression: ops::VarHandleOp(scope.WithOpName("var"), DataType::DT_FLOAT, {})
              qualified_identifier: ops::VarHandleOp
               namespace_identifier: ops
               ::: ::
               identifier: VarHandleOp
              argument_list: (scope.WithOpName("var"), DataType::DT_FLOAT, {})
               (: (
               call_expression: scope.WithOpName("var")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var")
                 (: (
                 string_literal: "var"
                  ": "
                  string_content: var
                  ": "
                 ): )
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ,: ,
               initializer_list: {}
                {: {
                }: }
               ): )
            ;: ;
           expression_statement: read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT);
            assignment_expression: read_var = ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
             identifier: read_var
             =: =
             call_expression: ops::ReadVariableOp(
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
              qualified_identifier: ops::ReadVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: ReadVariableOp
              argument_list: (
          scope.WithOpName("var/Read/ReadVariableOp"), var, DataType::DT_FLOAT)
               (: (
               call_expression: scope.WithOpName("var/Read/ReadVariableOp")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var/Read/ReadVariableOp")
                 (: (
                 string_literal: "var/Read/ReadVariableOp"
                  ": "
                  string_content: var/Read/ReadVariableOp
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ): )
            ;: ;
           declaration: auto assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a);
            placeholder_type_specifier: auto
             auto: auto
            init_declarator: assign = ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
             identifier: assign
             =: =
             call_expression: ops::AssignVariableOp(scope.WithOpName("assign"), var, a)
              qualified_identifier: ops::AssignVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: AssignVariableOp
              argument_list: (scope.WithOpName("assign"), var, a)
               (: (
               call_expression: scope.WithOpName("assign")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("assign")
                 (: (
                 string_literal: "assign"
                  ": "
                  string_content: assign
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               identifier: a
               ): )
            ;: ;
           declaration: Output var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {});
            type_identifier: Output
            init_declarator: var_1 =
          ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {})
             identifier: var_1
             =: =
             call_expression: ops::VarHandleOp(scope.WithOpName("var_1"), DataType::DT_FLOAT, {})
              qualified_identifier: ops::VarHandleOp
               namespace_identifier: ops
               ::: ::
               identifier: VarHandleOp
              argument_list: (scope.WithOpName("var_1"), DataType::DT_FLOAT, {})
               (: (
               call_expression: scope.WithOpName("var_1")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var_1")
                 (: (
                 string_literal: "var_1"
                  ": "
                  string_content: var_1
                  ": "
                 ): )
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ,: ,
               initializer_list: {}
                {: {
                }: }
               ): )
            ;: ;
           declaration: Output read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT);
            type_identifier: Output
            init_declarator: read_var_1 =
          ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT)
             identifier: read_var_1
             =: =
             call_expression: ops::ReadVariableOp(scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT)
              qualified_identifier: ops::ReadVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: ReadVariableOp
              argument_list: (scope.WithOpName("var_1/Read/ReadVariableOp"),
                              var, DataType::DT_FLOAT)
               (: (
               call_expression: scope.WithOpName("var_1/Read/ReadVariableOp")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("var_1/Read/ReadVariableOp")
                 (: (
                 string_literal: "var_1/Read/ReadVariableOp"
                  ": "
                  string_content: var_1/Read/ReadVariableOp
                  ": "
                 ): )
               ,: ,
               identifier: var
               ,: ,
               qualified_identifier: DataType::DT_FLOAT
                namespace_identifier: DataType
                ::: ::
                identifier: DT_FLOAT
               ): )
            ;: ;
           declaration: auto assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a);
            placeholder_type_specifier: auto
             auto: auto
            init_declarator: assign_1 =
          ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a)
             identifier: assign_1
             =: =
             call_expression: ops::AssignVariableOp(scope.WithOpName("assign_1"), var_1, a)
              qualified_identifier: ops::AssignVariableOp
               namespace_identifier: ops
               ::: ::
               identifier: AssignVariableOp
              argument_list: (scope.WithOpName("assign_1"), var_1, a)
               (: (
               call_expression: scope.WithOpName("assign_1")
                field_expression: scope.WithOpName
                 identifier: scope
                 .: .
                 field_identifier: WithOpName
                argument_list: ("assign_1")
                 (: (
                 string_literal: "assign_1"
                  ": "
                  string_content: assign_1
                  ": "
                 ): )
               ,: ,
               identifier: var_1
               ,: ,
               identifier: a
               ): )
            ;: ;
           }: }
          else_clause: else {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }
           else: else
           compound_statement: {
      read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
      Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
      Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
      Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
    }
            {: {
            expression_statement: read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT);
             assignment_expression: read_var = ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
              identifier: read_var
              =: =
              call_expression: ops::Variable(scope.WithOpName("var"), {}, DataType::DT_FLOAT)
               qualified_identifier: ops::Variable
                namespace_identifier: ops
                ::: ::
                identifier: Variable
               argument_list: (scope.WithOpName("var"), {}, DataType::DT_FLOAT)
                (: (
                call_expression: scope.WithOpName("var")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("var")
                  (: (
                  string_literal: "var"
                   ": "
                   string_content: var
                   ": "
                  ): )
                ,: ,
                initializer_list: {}
                 {: {
                 }: }
                ,: ,
                qualified_identifier: DataType::DT_FLOAT
                 namespace_identifier: DataType
                 ::: ::
                 identifier: DT_FLOAT
                ): )
             ;: ;
            declaration: Output assign = ops::Assign(scope.WithOpName("assign"), read_var, a);
             type_identifier: Output
             init_declarator: assign = ops::Assign(scope.WithOpName("assign"), read_var, a)
              identifier: assign
              =: =
              call_expression: ops::Assign(scope.WithOpName("assign"), read_var, a)
               qualified_identifier: ops::Assign
                namespace_identifier: ops
                ::: ::
                identifier: Assign
               argument_list: (scope.WithOpName("assign"), read_var, a)
                (: (
                call_expression: scope.WithOpName("assign")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("assign")
                  (: (
                  string_literal: "assign"
                   ": "
                   string_content: assign
                   ": "
                  ): )
                ,: ,
                identifier: read_var
                ,: ,
                identifier: a
                ): )
             ;: ;
            declaration: Output var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT);
             type_identifier: Output
             init_declarator: var_1 =
          ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT)
              identifier: var_1
              =: =
              call_expression: ops::Variable(scope.WithOpName("var_1"), {}, DataType::DT_FLOAT)
               qualified_identifier: ops::Variable
                namespace_identifier: ops
                ::: ::
                identifier: Variable
               argument_list: (scope.WithOpName("var_1"), {}, DataType::DT_FLOAT)
                (: (
                call_expression: scope.WithOpName("var_1")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("var_1")
                  (: (
                  string_literal: "var_1"
                   ": "
                   string_content: var_1
                   ": "
                  ): )
                ,: ,
                initializer_list: {}
                 {: {
                 }: }
                ,: ,
                qualified_identifier: DataType::DT_FLOAT
                 namespace_identifier: DataType
                 ::: ::
                 identifier: DT_FLOAT
                ): )
             ;: ;
            declaration: Output assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a);
             type_identifier: Output
             init_declarator: assign_1 = ops::Assign(scope.WithOpName("assign_1"), var_1, a)
              identifier: assign_1
              =: =
              call_expression: ops::Assign(scope.WithOpName("assign_1"), var_1, a)
               qualified_identifier: ops::Assign
                namespace_identifier: ops
                ::: ::
                identifier: Assign
               argument_list: (scope.WithOpName("assign_1"), var_1, a)
                (: (
                call_expression: scope.WithOpName("assign_1")
                 field_expression: scope.WithOpName
                  identifier: scope
                  .: .
                  field_identifier: WithOpName
                 argument_list: ("assign_1")
                  (: (
                  string_literal: "assign_1"
                   ": "
                   string_content: assign_1
                   ": "
                  ): )
                ,: ,
                identifier: var_1
                ,: ,
                identifier: a
                ): )
             ;: ;
            }: }
         declaration: Output c = ops::Mul(scope.WithOpName("c"), a, read_var);
          type_identifier: Output
          init_declarator: c = ops::Mul(scope.WithOpName("c"), a, read_var)
           identifier: c
           =: =
           call_expression: ops::Mul(scope.WithOpName("c"), a, read_var)
            qualified_identifier: ops::Mul
             namespace_identifier: ops
             ::: ::
             identifier: Mul
            argument_list: (scope.WithOpName("c"), a, read_var)
             (: (
             call_expression: scope.WithOpName("c")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("c")
               (: (
               string_literal: "c"
                ": "
                string_content: c
                ": "
               ): )
             ,: ,
             identifier: a
             ,: ,
             identifier: read_var
             ): )
          ;: ;
         expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
          call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
           identifier: TF_ASSERT_OK
           argument_list: (scope.ToGraphDef(&graph_def))
            (: (
            call_expression: scope.ToGraphDef(&graph_def)
             field_expression: scope.ToGraphDef
              identifier: scope
              .: .
              field_identifier: ToGraphDef
             argument_list: (&graph_def)
              (: (
              pointer_expression: &graph_def
               &: &
               identifier: graph_def
              ): )
            ): )
          ;: ;
         comment: // "c" isn't dependent on the variable, so nothing should be frozen.
         expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle));
          call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
           identifier: TF_ASSERT_OK
           argument_list: (AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle))
            (: (
            call_expression: AddGraphDefWithOutputsToSavedModelBundle(
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
             identifier: AddGraphDefWithOutputsToSavedModelBundle
             argument_list: (
        graph_def, {"c:0"}, "assign", &saved_model_bundle)
              (: (
              identifier: graph_def
              ,: ,
              initializer_list: {"c:0"}
               {: {
               string_literal: "c:0"
                ": "
                string_content: c:0
                ": "
               }: }
              ,: ,
              string_literal: "assign"
               ": "
               string_content: assign
               ": "
              ,: ,
              pointer_expression: &saved_model_bundle
               &: &
               identifier: saved_model_bundle
              ): )
            ): )
          ;: ;
         declaration: GraphDef frozen_graph_def;
          type_identifier: GraphDef
          identifier: frozen_graph_def
          ;: ;
         declaration: std::unordered_set<string> inputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: inputs
          ;: ;
         declaration: std::unordered_set<string> outputs;
          qualified_identifier: std::unordered_set<string>
           namespace_identifier: std
           ::: ::
           template_type: unordered_set<string>
            type_identifier: unordered_set
            template_argument_list: <string>
             <: <
             type_descriptor: string
              type_identifier: string
             >: >
          identifier: outputs
          ;: ;
         expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs));
          call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
           identifier: TF_ASSERT_OK
           argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs))
            (: (
            call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
             identifier: FreezeSavedModel
             argument_list: (saved_model_bundle, &frozen_graph_def,
                                  &inputs, &outputs)
              (: (
              identifier: saved_model_bundle
              ,: ,
              pointer_expression: &frozen_graph_def
               &: &
               identifier: frozen_graph_def
              ,: ,
              pointer_expression: &inputs
               &: &
               identifier: inputs
              ,: ,
              pointer_expression: &outputs
               &: &
               identifier: outputs
              ): )
            ): )
          ;: ;
         comment: // There should be 3 nodes in the resulting graph_def, and none should be
         comment: // variables.
         declaration: size_t expected_nodes = use_resource ? 4 : 3;
          primitive_type: size_t
          init_declarator: expected_nodes = use_resource ? 4 : 3
           identifier: expected_nodes
           =: =
           conditional_expression: use_resource ? 4 : 3
            identifier: use_resource
            ?: ?
            number_literal: 4
            :: :
            number_literal: 3
          ;: ;
         expression_statement: EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes);
          call_expression: EXPECT_EQ(frozen_graph_def.node_size(), expected_nodes)
           identifier: EXPECT_EQ
           argument_list: (frozen_graph_def.node_size(), expected_nodes)
            (: (
            call_expression: frozen_graph_def.node_size()
             field_expression: frozen_graph_def.node_size
              identifier: frozen_graph_def
              .: .
              field_identifier: node_size
             argument_list: ()
              (: (
              ): )
            ,: ,
            identifier: expected_nodes
            ): )
          ;: ;
         for_range_loop: for (const NodeDef& node : frozen_graph_def.node()) {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }
          for: for
          (: (
          type_qualifier: const
           const: const
          type_identifier: NodeDef
          reference_declarator: & node
           &: &
           identifier: node
          :: :
          call_expression: frozen_graph_def.node()
           field_expression: frozen_graph_def.node
            identifier: frozen_graph_def
            .: .
            field_identifier: node
           argument_list: ()
            (: (
            ): )
          ): )
          compound_statement: {
      EXPECT_NE(node.op(), "Variable") << node.name();
      EXPECT_NE(node.op(), "VariableV2") << node.name();
      EXPECT_NE(node.op(), "VarHandleOp") << node.name();
      EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
    }
           {: {
           expression_statement: EXPECT_NE(node.op(), "Variable") << node.name();
            binary_expression: EXPECT_NE(node.op(), "Variable") << node.name()
             call_expression: EXPECT_NE(node.op(), "Variable")
              identifier: EXPECT_NE
              argument_list: (node.op(), "Variable")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "Variable"
                ": "
                string_content: Variable
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "VariableV2") << node.name();
            binary_expression: EXPECT_NE(node.op(), "VariableV2") << node.name()
             call_expression: EXPECT_NE(node.op(), "VariableV2")
              identifier: EXPECT_NE
              argument_list: (node.op(), "VariableV2")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "VariableV2"
                ": "
                string_content: VariableV2
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "VarHandleOp") << node.name();
            binary_expression: EXPECT_NE(node.op(), "VarHandleOp") << node.name()
             call_expression: EXPECT_NE(node.op(), "VarHandleOp")
              identifier: EXPECT_NE
              argument_list: (node.op(), "VarHandleOp")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "VarHandleOp"
                ": "
                string_content: VarHandleOp
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           expression_statement: EXPECT_NE(node.op(), "ReadVariableOp") << node.name();
            binary_expression: EXPECT_NE(node.op(), "ReadVariableOp") << node.name()
             call_expression: EXPECT_NE(node.op(), "ReadVariableOp")
              identifier: EXPECT_NE
              argument_list: (node.op(), "ReadVariableOp")
               (: (
               call_expression: node.op()
                field_expression: node.op
                 identifier: node
                 .: .
                 field_identifier: op
                argument_list: ()
                 (: (
                 ): )
               ,: ,
               string_literal: "ReadVariableOp"
                ": "
                string_content: ReadVariableOp
                ": "
               ): )
             <<: <<
             call_expression: node.name()
              field_expression: node.name
               identifier: node
               .: .
               field_identifier: name
              argument_list: ()
               (: (
               ): )
            ;: ;
           }: }
         expression_statement: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0");
          call_expression: RunAndCompareFrozenAndUnfrozenGraphs(saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
           identifier: RunAndCompareFrozenAndUnfrozenGraphs
           argument_list: (saved_model_bundle.session.get(),
                                         frozen_graph_def, "c:0")
            (: (
            call_expression: saved_model_bundle.session.get()
             field_expression: saved_model_bundle.session.get
              field_expression: saved_model_bundle.session
               identifier: saved_model_bundle
               .: .
               field_identifier: session
              .: .
              field_identifier: get
             argument_list: ()
              (: (
              ): )
            ,: ,
            identifier: frozen_graph_def
            ,: ,
            string_literal: "c:0"
             ": "
             string_content: c:0
             ": "
            ): )
          ;: ;
         }: }
       }: }
     ;: ;
     function_definition: TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef) {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
      function_declarator: TEST_F(FreezeTest, InputsAndOutputsSingleSignatureDef)
       identifier: TEST_F
       parameter_list: (FreezeTest, InputsAndOutputsSingleSignatureDef)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: InputsAndOutputsSingleSignatureDef
         type_identifier: InputsAndOutputsSingleSignatureDef
        ): )
      compound_statement: {
  // Test that inputs and outputs get correctly populated for a single
  // SignatureDef.
  SavedModelBundle saved_model_bundle;
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
       {: {
       comment: // Test that inputs and outputs get correctly populated for a single
       comment: // SignatureDef.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_inputs = {"input0:0", "input1:0"}
         identifier: expected_inputs
         =: =
         initializer_list: {"input0:0", "input1:0"}
          {: {
          string_literal: "input0:0"
           ": "
           string_content: input0:0
           ": "
          ,: ,
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          }: }
        ;: ;
       declaration: std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_outputs = {"output0:0", "output1:0"}
         identifier: expected_outputs
         =: =
         initializer_list: {"output0:0", "output1:0"}
          {: {
          string_literal: "output0:0"
           ": "
           string_content: output0:0
           ": "
          ,: ,
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          }: }
        ;: ;
       declaration: SignatureDef signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs);
        type_identifier: SignatureDef
        init_declarator: signature_def =
      BuildSignatureDef(expected_inputs, expected_outputs)
         identifier: signature_def
         =: =
         call_expression: BuildSignatureDef(expected_inputs, expected_outputs)
          identifier: BuildSignatureDef
          argument_list: (expected_inputs, expected_outputs)
           (: (
           identifier: expected_inputs
           ,: ,
           identifier: expected_outputs
           ): )
        ;: ;
       expression_statement: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
        call_expression: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle)
         identifier: AddSignatureDefToSavedModelBundle
         argument_list: (signature_def, "signature_def",
                                    &saved_model_bundle)
          (: (
          identifier: signature_def
          ,: ,
          string_literal: "signature_def"
           ": "
           string_content: signature_def
           ": "
          ,: ,
          pointer_expression: &saved_model_bundle
           &: &
           identifier: saved_model_bundle
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       expression_statement: EXPECT_EQ(expected_inputs, inputs);
        call_expression: EXPECT_EQ(expected_inputs, inputs)
         identifier: EXPECT_EQ
         argument_list: (expected_inputs, inputs)
          (: (
          identifier: expected_inputs
          ,: ,
          identifier: inputs
          ): )
        ;: ;
       expression_statement: EXPECT_EQ(expected_outputs, outputs);
        call_expression: EXPECT_EQ(expected_outputs, outputs)
         identifier: EXPECT_EQ
         argument_list: (expected_outputs, outputs)
          (: (
          identifier: expected_outputs
          ,: ,
          identifier: outputs
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs) {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
      function_declarator: TEST_F(FreezeTest, InputsAndOutputsMultipleSignatureDefs)
       identifier: TEST_F
       parameter_list: (FreezeTest, InputsAndOutputsMultipleSignatureDefs)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: InputsAndOutputsMultipleSignatureDefs
         type_identifier: InputsAndOutputsMultipleSignatureDefs
        ): )
      compound_statement: {
  // Test that inputs and outputs get correctly merged and populated when
  // multiple SignatureDefs are provided.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
  SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
  AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
  AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
  std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
       {: {
       comment: // Test that inputs and outputs get correctly merged and populated when
       comment: // multiple SignatureDefs are provided.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: SignatureDef signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"});
        type_identifier: SignatureDef
        init_declarator: signature_def_0 = BuildSignatureDef({"input0:0"}, {"output0:0"})
         identifier: signature_def_0
         =: =
         call_expression: BuildSignatureDef({"input0:0"}, {"output0:0"})
          identifier: BuildSignatureDef
          argument_list: ({"input0:0"}, {"output0:0"})
           (: (
           initializer_list: {"input0:0"}
            {: {
            string_literal: "input0:0"
             ": "
             string_content: input0:0
             ": "
            }: }
           ,: ,
           initializer_list: {"output0:0"}
            {: {
            string_literal: "output0:0"
             ": "
             string_content: output0:0
             ": "
            }: }
           ): )
        ;: ;
       declaration: SignatureDef signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"});
        type_identifier: SignatureDef
        init_declarator: signature_def_1 = BuildSignatureDef({"input1:0"}, {"output1:0"})
         identifier: signature_def_1
         =: =
         call_expression: BuildSignatureDef({"input1:0"}, {"output1:0"})
          identifier: BuildSignatureDef
          argument_list: ({"input1:0"}, {"output1:0"})
           (: (
           initializer_list: {"input1:0"}
            {: {
            string_literal: "input1:0"
             ": "
             string_content: input1:0
             ": "
            }: }
           ,: ,
           initializer_list: {"output1:0"}
            {: {
            string_literal: "output1:0"
             ": "
             string_content: output1:0
             ": "
            }: }
           ): )
        ;: ;
       expression_statement: AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle);
        call_expression: AddSignatureDefToSavedModelBundle(signature_def_0, "signature_def_0",
                                    &saved_model_bundle)
         identifier: AddSignatureDefToSavedModelBundle
         argument_list: (signature_def_0, "signature_def_0",
                                    &saved_model_bundle)
          (: (
          identifier: signature_def_0
          ,: ,
          string_literal: "signature_def_0"
           ": "
           string_content: signature_def_0
           ": "
          ,: ,
          pointer_expression: &saved_model_bundle
           &: &
           identifier: saved_model_bundle
          ): )
        ;: ;
       expression_statement: AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle);
        call_expression: AddSignatureDefToSavedModelBundle(signature_def_1, "signature_def_1",
                                    &saved_model_bundle)
         identifier: AddSignatureDefToSavedModelBundle
         argument_list: (signature_def_1, "signature_def_1",
                                    &saved_model_bundle)
          (: (
          identifier: signature_def_1
          ,: ,
          string_literal: "signature_def_1"
           ": "
           string_content: signature_def_1
           ": "
          ,: ,
          pointer_expression: &saved_model_bundle
           &: &
           identifier: saved_model_bundle
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       declaration: std::unordered_set<string> expected_inputs = {"input0:0", "input1:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_inputs = {"input0:0", "input1:0"}
         identifier: expected_inputs
         =: =
         initializer_list: {"input0:0", "input1:0"}
          {: {
          string_literal: "input0:0"
           ": "
           string_content: input0:0
           ": "
          ,: ,
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          }: }
        ;: ;
       declaration: std::unordered_set<string> expected_outputs = {"output0:0", "output1:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_outputs = {"output0:0", "output1:0"}
         identifier: expected_outputs
         =: =
         initializer_list: {"output0:0", "output1:0"}
          {: {
          string_literal: "output0:0"
           ": "
           string_content: output0:0
           ": "
          ,: ,
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          }: }
        ;: ;
       expression_statement: EXPECT_EQ(expected_inputs, inputs);
        call_expression: EXPECT_EQ(expected_inputs, inputs)
         identifier: EXPECT_EQ
         argument_list: (expected_inputs, inputs)
          (: (
          identifier: expected_inputs
          ,: ,
          identifier: inputs
          ): )
        ;: ;
       expression_statement: EXPECT_EQ(expected_outputs, outputs);
        call_expression: EXPECT_EQ(expected_outputs, outputs)
         identifier: EXPECT_EQ
         argument_list: (expected_outputs, outputs)
          (: (
          identifier: expected_outputs
          ,: ,
          identifier: outputs
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefVersionsAndLibrary) {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
      function_declarator: TEST_F(FreezeTest, GraphDefVersionsAndLibrary)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefVersionsAndLibrary)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefVersionsAndLibrary
         type_identifier: GraphDefVersionsAndLibrary
        ): )
      compound_statement: {
  // Test that GraphDef versions and library are copied correctly into the
  // frozen graph.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  graph_def.mutable_versions()->set_producer(1234);
  graph_def.mutable_versions()->set_min_consumer(1234);
  *graph_def.mutable_library()->add_function() = test::function::NonZero();
  TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
       {: {
       comment: // Test that GraphDef versions and library are copied correctly into the
       comment: // frozen graph.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: GraphDef graph_def;
        type_identifier: GraphDef
        identifier: graph_def
        ;: ;
       expression_statement: graph_def.mutable_versions()->set_producer(1234);
        call_expression: graph_def.mutable_versions()->set_producer(1234)
         field_expression: graph_def.mutable_versions()->set_producer
          call_expression: graph_def.mutable_versions()
           field_expression: graph_def.mutable_versions
            identifier: graph_def
            .: .
            field_identifier: mutable_versions
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_producer
         argument_list: (1234)
          (: (
          number_literal: 1234
          ): )
        ;: ;
       expression_statement: graph_def.mutable_versions()->set_min_consumer(1234);
        call_expression: graph_def.mutable_versions()->set_min_consumer(1234)
         field_expression: graph_def.mutable_versions()->set_min_consumer
          call_expression: graph_def.mutable_versions()
           field_expression: graph_def.mutable_versions
            identifier: graph_def
            .: .
            field_identifier: mutable_versions
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_min_consumer
         argument_list: (1234)
          (: (
          number_literal: 1234
          ): )
        ;: ;
       expression_statement: *graph_def.mutable_library()->add_function() = test::function::NonZero();
        assignment_expression: *graph_def.mutable_library()->add_function() = test::function::NonZero()
         pointer_expression: *graph_def.mutable_library()->add_function()
          *: *
          call_expression: graph_def.mutable_library()->add_function()
           field_expression: graph_def.mutable_library()->add_function
            call_expression: graph_def.mutable_library()
             field_expression: graph_def.mutable_library
              identifier: graph_def
              .: .
              field_identifier: mutable_library
             argument_list: ()
              (: (
              ): )
            ->: ->
            field_identifier: add_function
           argument_list: ()
            (: (
            ): )
         =: =
         call_expression: test::function::NonZero()
          qualified_identifier: test::function::NonZero
           namespace_identifier: test
           ::: ::
           qualified_identifier: function::NonZero
            namespace_identifier: function
            ::: ::
            identifier: NonZero
          argument_list: ()
           (: (
           ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle));
        call_expression: TF_ASSERT_OK(
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle))
         identifier: TF_ASSERT_OK
         argument_list: (
      AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle))
          (: (
          call_expression: AddGraphDefToSavedModelBundle(graph_def, "", &saved_model_bundle)
           identifier: AddGraphDefToSavedModelBundle
           argument_list: (graph_def, "", &saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            string_literal: ""
             ": "
             ": "
            ,: ,
            pointer_expression: &saved_model_bundle
             &: &
             identifier: saved_model_bundle
            ): )
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       expression_statement: GraphDefEqual(frozen_graph_def, graph_def);
        call_expression: GraphDefEqual(frozen_graph_def, graph_def)
         identifier: GraphDefEqual
         argument_list: (frozen_graph_def, graph_def)
          (: (
          identifier: frozen_graph_def
          ,: ,
          identifier: graph_def
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithNoVariables) {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithNoVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithNoVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithNoVariables
         type_identifier: GraphDefWithNoVariables
        ): )
      compound_statement: {
  // Test freezing a graph with no variables.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
       {: {
       comment: // Test freezing a graph with no variables.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: GraphDef graph_def;
        type_identifier: GraphDef
        identifier: graph_def
        ;: ;
       declaration: Scope scope = Scope::NewRootScope();
        type_identifier: Scope
        init_declarator: scope = Scope::NewRootScope()
         identifier: scope
         =: =
         call_expression: Scope::NewRootScope()
          qualified_identifier: Scope::NewRootScope
           namespace_identifier: Scope
           ::: ::
           identifier: NewRootScope
          argument_list: ()
           (: (
           ): )
        ;: ;
       declaration: Output a = ops::Const(scope.WithOpName("a"), 10.0f, {});
        type_identifier: Output
        init_declarator: a = ops::Const(scope.WithOpName("a"), 10.0f, {})
         identifier: a
         =: =
         call_expression: ops::Const(scope.WithOpName("a"), 10.0f, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("a"), 10.0f, {})
           (: (
           call_expression: scope.WithOpName("a")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("a")
             (: (
             string_literal: "a"
              ": "
              string_content: a
              ": "
             ): )
           ,: ,
           number_literal: 10.0f
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
        type_identifier: Output
        init_declarator: b = ops::Const(scope.WithOpName("b"), 10.0f, {})
         identifier: b
         =: =
         call_expression: ops::Const(scope.WithOpName("b"), 10.0f, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("b"), 10.0f, {})
           (: (
           call_expression: scope.WithOpName("b")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("b")
             (: (
             string_literal: "b"
              ": "
              string_content: b
              ": "
             ): )
           ,: ,
           number_literal: 10.0f
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: Output c = ops::Mul(scope.WithOpName("c"), a, b);
        type_identifier: Output
        init_declarator: c = ops::Mul(scope.WithOpName("c"), a, b)
         identifier: c
         =: =
         call_expression: ops::Mul(scope.WithOpName("c"), a, b)
          qualified_identifier: ops::Mul
           namespace_identifier: ops
           ::: ::
           identifier: Mul
          argument_list: (scope.WithOpName("c"), a, b)
           (: (
           call_expression: scope.WithOpName("c")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("c")
             (: (
             string_literal: "c"
              ": "
              string_content: c
              ": "
             ): )
           ,: ,
           identifier: a
           ,: ,
           identifier: b
           ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
        call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
         identifier: TF_ASSERT_OK
         argument_list: (scope.ToGraphDef(&graph_def))
          (: (
          call_expression: scope.ToGraphDef(&graph_def)
           field_expression: scope.ToGraphDef
            identifier: scope
            .: .
            field_identifier: ToGraphDef
           argument_list: (&graph_def)
            (: (
            pointer_expression: &graph_def
             &: &
             identifier: graph_def
            ): )
          ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));
        call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
         identifier: TF_ASSERT_OK
         argument_list: (AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
          (: (
          call_expression: AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
           identifier: AddGraphDefWithOutputsToSavedModelBundle
           argument_list: (graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            initializer_list: {"c:0"}
             {: {
             string_literal: "c:0"
              ": "
              string_content: c:0
              ": "
             }: }
            ,: ,
            string_literal: ""
             ": "
             ": "
            ,: ,
            pointer_expression: &saved_model_bundle
             &: &
             identifier: saved_model_bundle
            ): )
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       expression_statement: GraphDefEqual(frozen_graph_def, graph_def);
        call_expression: GraphDefEqual(frozen_graph_def, graph_def)
         identifier: GraphDefEqual
         argument_list: (frozen_graph_def, graph_def)
          (: (
          identifier: frozen_graph_def
          ,: ,
          identifier: graph_def
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithMultiOutputOperation) {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithMultiOutputOperation)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithMultiOutputOperation)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithMultiOutputOperation
         type_identifier: GraphDefWithMultiOutputOperation
        ): )
      compound_statement: {
  // Tensors from operations with multiple outputs get tensor suffixes when used
  // in input fields of following nodes, i.e. split:0, split:1.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
  Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
  OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
       {: {
       comment: // Tensors from operations with multiple outputs get tensor suffixes when used
       comment: // in input fields of following nodes, i.e. split:0, split:1.
       comment: // Test that we traverse those correctly.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: GraphDef graph_def;
        type_identifier: GraphDef
        identifier: graph_def
        ;: ;
       declaration: Scope scope = Scope::NewRootScope();
        type_identifier: Scope
        init_declarator: scope = Scope::NewRootScope()
         identifier: scope
         =: =
         call_expression: Scope::NewRootScope()
          qualified_identifier: Scope::NewRootScope
           namespace_identifier: Scope
           ::: ::
           identifier: NewRootScope
          argument_list: ()
           (: (
           ): )
        ;: ;
       declaration: Output a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2});
        type_identifier: Output
        init_declarator: a = ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2})
         identifier: a
         =: =
         call_expression: ops::Const(scope.WithOpName("a"), {10.0f, 10.0f}, {2})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("a"), {10.0f, 10.0f}, {2})
           (: (
           call_expression: scope.WithOpName("a")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("a")
             (: (
             string_literal: "a"
              ": "
              string_content: a
              ": "
             ): )
           ,: ,
           initializer_list: {10.0f, 10.0f}
            {: {
            number_literal: 10.0f
            ,: ,
            number_literal: 10.0f
            }: }
           ,: ,
           initializer_list: {2}
            {: {
            number_literal: 2
            }: }
           ): )
        ;: ;
       declaration: Output axis = ops::Const(scope.WithOpName("axis"), 0, {});
        type_identifier: Output
        init_declarator: axis = ops::Const(scope.WithOpName("axis"), 0, {})
         identifier: axis
         =: =
         call_expression: ops::Const(scope.WithOpName("axis"), 0, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("axis"), 0, {})
           (: (
           call_expression: scope.WithOpName("axis")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("axis")
             (: (
             string_literal: "axis"
              ": "
              string_content: axis
              ": "
             ): )
           ,: ,
           number_literal: 0
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: OutputList split = ops::Split(scope.WithOpName("split"), axis, a, 2).output;
        type_identifier: OutputList
        init_declarator: split = ops::Split(scope.WithOpName("split"), axis, a, 2).output
         identifier: split
         =: =
         field_expression: ops::Split(scope.WithOpName("split"), axis, a, 2).output
          call_expression: ops::Split(scope.WithOpName("split"), axis, a, 2)
           qualified_identifier: ops::Split
            namespace_identifier: ops
            ::: ::
            identifier: Split
           argument_list: (scope.WithOpName("split"), axis, a, 2)
            (: (
            call_expression: scope.WithOpName("split")
             field_expression: scope.WithOpName
              identifier: scope
              .: .
              field_identifier: WithOpName
             argument_list: ("split")
              (: (
              string_literal: "split"
               ": "
               string_content: split
               ": "
              ): )
            ,: ,
            identifier: axis
            ,: ,
            identifier: a
            ,: ,
            number_literal: 2
            ): )
          .: .
          field_identifier: output
        ;: ;
       declaration: Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
        type_identifier: Output
        init_declarator: b = ops::Const(scope.WithOpName("b"), 10.0f, {})
         identifier: b
         =: =
         call_expression: ops::Const(scope.WithOpName("b"), 10.0f, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("b"), 10.0f, {})
           (: (
           call_expression: scope.WithOpName("b")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("b")
             (: (
             string_literal: "b"
              ": "
              string_content: b
              ": "
             ): )
           ,: ,
           number_literal: 10.0f
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: Output c = ops::Mul(scope.WithOpName("c"), split[1], b);
        type_identifier: Output
        init_declarator: c = ops::Mul(scope.WithOpName("c"), split[1], b)
         identifier: c
         =: =
         call_expression: ops::Mul(scope.WithOpName("c"), split[1], b)
          qualified_identifier: ops::Mul
           namespace_identifier: ops
           ::: ::
           identifier: Mul
          argument_list: (scope.WithOpName("c"), split[1], b)
           (: (
           call_expression: scope.WithOpName("c")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("c")
             (: (
             string_literal: "c"
              ": "
              string_content: c
              ": "
             ): )
           ,: ,
           subscript_expression: split[1]
            identifier: split
            subscript_argument_list: [1]
             [: [
             number_literal: 1
             ]: ]
           ,: ,
           identifier: b
           ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
        call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
         identifier: TF_ASSERT_OK
         argument_list: (scope.ToGraphDef(&graph_def))
          (: (
          call_expression: scope.ToGraphDef(&graph_def)
           field_expression: scope.ToGraphDef
            identifier: scope
            .: .
            field_identifier: ToGraphDef
           argument_list: (&graph_def)
            (: (
            pointer_expression: &graph_def
             &: &
             identifier: graph_def
            ): )
          ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));
        call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
         identifier: TF_ASSERT_OK
         argument_list: (AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
          (: (
          call_expression: AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
           identifier: AddGraphDefWithOutputsToSavedModelBundle
           argument_list: (graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            initializer_list: {"c:0"}
             {: {
             string_literal: "c:0"
              ": "
              string_content: c:0
              ": "
             }: }
            ,: ,
            string_literal: ""
             ": "
             ": "
            ,: ,
            pointer_expression: &saved_model_bundle
             &: &
             identifier: saved_model_bundle
            ): )
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       expression_statement: GraphDefEqual(frozen_graph_def, graph_def);
        call_expression: GraphDefEqual(frozen_graph_def, graph_def)
         identifier: GraphDefEqual
         argument_list: (frozen_graph_def, graph_def)
          (: (
          identifier: frozen_graph_def
          ,: ,
          identifier: graph_def
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithControlDependency) {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithControlDependency)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithControlDependency)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithControlDependency
         type_identifier: GraphDefWithControlDependency
        ): )
      compound_statement: {
  // Inputs that are control dependencies get tensor prefixes,
  // i.e. ^control_dependency.
  // Test that we traverse those correctly.
  SavedModelBundle saved_model_bundle;
  GraphDef graph_def;
  Scope scope = Scope::NewRootScope();
  Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
  Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
  Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
  Output c = ops::Mul(scope.WithOpName("c"), a, b);
  TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
  TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));

  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));

  GraphDefEqual(frozen_graph_def, graph_def);
}
       {: {
       comment: // Inputs that are control dependencies get tensor prefixes,
       comment: // i.e. ^control_dependency.
       comment: // Test that we traverse those correctly.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: GraphDef graph_def;
        type_identifier: GraphDef
        identifier: graph_def
        ;: ;
       declaration: Scope scope = Scope::NewRootScope();
        type_identifier: Scope
        init_declarator: scope = Scope::NewRootScope()
         identifier: scope
         =: =
         call_expression: Scope::NewRootScope()
          qualified_identifier: Scope::NewRootScope
           namespace_identifier: Scope
           ::: ::
           identifier: NewRootScope
          argument_list: ()
           (: (
           ): )
        ;: ;
       declaration: Output source = ops::Const(scope.WithOpName("source"), 10.0f, {});
        type_identifier: Output
        init_declarator: source = ops::Const(scope.WithOpName("source"), 10.0f, {})
         identifier: source
         =: =
         call_expression: ops::Const(scope.WithOpName("source"), 10.0f, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("source"), 10.0f, {})
           (: (
           call_expression: scope.WithOpName("source")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("source")
             (: (
             string_literal: "source"
              ": "
              string_content: source
              ": "
             ): )
           ,: ,
           number_literal: 10.0f
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: Output a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2});
        type_identifier: Output
        init_declarator: a = ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2})
         identifier: a
         =: =
         call_expression: ops::Const(scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("a").WithControlDependencies(source),
                        {10.0f, 10.0f}, {2})
           (: (
           call_expression: scope.WithOpName("a").WithControlDependencies(source)
            field_expression: scope.WithOpName("a").WithControlDependencies
             call_expression: scope.WithOpName("a")
              field_expression: scope.WithOpName
               identifier: scope
               .: .
               field_identifier: WithOpName
              argument_list: ("a")
               (: (
               string_literal: "a"
                ": "
                string_content: a
                ": "
               ): )
             .: .
             field_identifier: WithControlDependencies
            argument_list: (source)
             (: (
             identifier: source
             ): )
           ,: ,
           initializer_list: {10.0f, 10.0f}
            {: {
            number_literal: 10.0f
            ,: ,
            number_literal: 10.0f
            }: }
           ,: ,
           initializer_list: {2}
            {: {
            number_literal: 2
            }: }
           ): )
        ;: ;
       declaration: Output b = ops::Const(scope.WithOpName("b"), 10.0f, {});
        type_identifier: Output
        init_declarator: b = ops::Const(scope.WithOpName("b"), 10.0f, {})
         identifier: b
         =: =
         call_expression: ops::Const(scope.WithOpName("b"), 10.0f, {})
          qualified_identifier: ops::Const
           namespace_identifier: ops
           ::: ::
           identifier: Const
          argument_list: (scope.WithOpName("b"), 10.0f, {})
           (: (
           call_expression: scope.WithOpName("b")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("b")
             (: (
             string_literal: "b"
              ": "
              string_content: b
              ": "
             ): )
           ,: ,
           number_literal: 10.0f
           ,: ,
           initializer_list: {}
            {: {
            }: }
           ): )
        ;: ;
       declaration: Output c = ops::Mul(scope.WithOpName("c"), a, b);
        type_identifier: Output
        init_declarator: c = ops::Mul(scope.WithOpName("c"), a, b)
         identifier: c
         =: =
         call_expression: ops::Mul(scope.WithOpName("c"), a, b)
          qualified_identifier: ops::Mul
           namespace_identifier: ops
           ::: ::
           identifier: Mul
          argument_list: (scope.WithOpName("c"), a, b)
           (: (
           call_expression: scope.WithOpName("c")
            field_expression: scope.WithOpName
             identifier: scope
             .: .
             field_identifier: WithOpName
            argument_list: ("c")
             (: (
             string_literal: "c"
              ": "
              string_content: c
              ": "
             ): )
           ,: ,
           identifier: a
           ,: ,
           identifier: b
           ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(scope.ToGraphDef(&graph_def));
        call_expression: TF_ASSERT_OK(scope.ToGraphDef(&graph_def))
         identifier: TF_ASSERT_OK
         argument_list: (scope.ToGraphDef(&graph_def))
          (: (
          call_expression: scope.ToGraphDef(&graph_def)
           field_expression: scope.ToGraphDef
            identifier: scope
            .: .
            field_identifier: ToGraphDef
           argument_list: (&graph_def)
            (: (
            pointer_expression: &graph_def
             &: &
             identifier: graph_def
            ): )
          ): )
        ;: ;
       expression_statement: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle));
        call_expression: TF_ASSERT_OK(AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
         identifier: TF_ASSERT_OK
         argument_list: (AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle))
          (: (
          call_expression: AddGraphDefWithOutputsToSavedModelBundle(graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
           identifier: AddGraphDefWithOutputsToSavedModelBundle
           argument_list: (graph_def, {"c:0"}, "",
                                                        &saved_model_bundle)
            (: (
            identifier: graph_def
            ,: ,
            initializer_list: {"c:0"}
             {: {
             string_literal: "c:0"
              ": "
              string_content: c:0
              ": "
             }: }
            ,: ,
            string_literal: ""
             ": "
             ": "
            ,: ,
            pointer_expression: &saved_model_bundle
             &: &
             identifier: saved_model_bundle
            ): )
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       expression_statement: GraphDefEqual(frozen_graph_def, graph_def);
        call_expression: GraphDefEqual(frozen_graph_def, graph_def)
         identifier: GraphDefEqual
         argument_list: (frozen_graph_def, graph_def)
          (: (
          identifier: frozen_graph_def
          ,: ,
          identifier: graph_def
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithoutDependentVariables) {
  TestFreezeGraphWithoutDependentVariables(false);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithoutDependentVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithoutDependentVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithoutDependentVariables
         type_identifier: GraphDefWithoutDependentVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithoutDependentVariables(false);
}
       {: {
       expression_statement: TestFreezeGraphWithoutDependentVariables(false);
        call_expression: TestFreezeGraphWithoutDependentVariables(false)
         identifier: TestFreezeGraphWithoutDependentVariables
         argument_list: (false)
          (: (
          false: false
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables) {
  TestFreezeGraphWithoutDependentVariables(true);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithoutDependentResourceVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithoutDependentResourceVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithoutDependentResourceVariables
         type_identifier: GraphDefWithoutDependentResourceVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithoutDependentVariables(true);
}
       {: {
       expression_statement: TestFreezeGraphWithoutDependentVariables(true);
        call_expression: TestFreezeGraphWithoutDependentVariables(true)
         identifier: TestFreezeGraphWithoutDependentVariables
         argument_list: (true)
          (: (
          true: true
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithDependentVariables) {
  TestFreezeGraphWithDependentVariables(false);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithDependentVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithDependentVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithDependentVariables
         type_identifier: GraphDefWithDependentVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithDependentVariables(false);
}
       {: {
       expression_statement: TestFreezeGraphWithDependentVariables(false);
        call_expression: TestFreezeGraphWithDependentVariables(false)
         identifier: TestFreezeGraphWithDependentVariables
         argument_list: (false)
          (: (
          false: false
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithDependentResourceVariables) {
  TestFreezeGraphWithDependentVariables(true);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithDependentResourceVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithDependentResourceVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithDependentResourceVariables
         type_identifier: GraphDefWithDependentResourceVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithDependentVariables(true);
}
       {: {
       expression_statement: TestFreezeGraphWithDependentVariables(true);
        call_expression: TestFreezeGraphWithDependentVariables(true)
         identifier: TestFreezeGraphWithDependentVariables
         argument_list: (true)
          (: (
          true: true
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity) {
  TestFreezeGraphWithDependentVariables(true, true);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithDependentResourceVariablesAndIdentity)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithDependentResourceVariablesAndIdentity
         type_identifier: GraphDefWithDependentResourceVariablesAndIdentity
        ): )
      compound_statement: {
  TestFreezeGraphWithDependentVariables(true, true);
}
       {: {
       expression_statement: TestFreezeGraphWithDependentVariables(true, true);
        call_expression: TestFreezeGraphWithDependentVariables(true, true)
         identifier: TestFreezeGraphWithDependentVariables
         argument_list: (true, true)
          (: (
          true: true
          ,: ,
          true: true
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithAndWithoutDependentVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithAndWithoutDependentVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithAndWithoutDependentVariables
         type_identifier: GraphDefWithAndWithoutDependentVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithAndWithoutDependentVariables(false);
}
       {: {
       expression_statement: TestFreezeGraphWithAndWithoutDependentVariables(false);
        call_expression: TestFreezeGraphWithAndWithoutDependentVariables(false)
         identifier: TestFreezeGraphWithAndWithoutDependentVariables
         argument_list: (false)
          (: (
          false: false
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables) {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}
      function_declarator: TEST_F(FreezeTest, GraphDefWithAndWithoutDependentResourceVariables)
       identifier: TEST_F
       parameter_list: (FreezeTest, GraphDefWithAndWithoutDependentResourceVariables)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: GraphDefWithAndWithoutDependentResourceVariables
         type_identifier: GraphDefWithAndWithoutDependentResourceVariables
        ): )
      compound_statement: {
  TestFreezeGraphWithAndWithoutDependentVariables(true);
}
       {: {
       expression_statement: TestFreezeGraphWithAndWithoutDependentVariables(true);
        call_expression: TestFreezeGraphWithAndWithoutDependentVariables(true)
         identifier: TestFreezeGraphWithAndWithoutDependentVariables
         argument_list: (true)
          (: (
          true: true
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
      function_declarator: TEST_F(FreezeTest, InputsAndOutputsCompositeTensorSignatureDef)
       identifier: TEST_F
       parameter_list: (FreezeTest, InputsAndOutputsCompositeTensorSignatureDef)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: InputsAndOutputsCompositeTensorSignatureDef
         type_identifier: InputsAndOutputsCompositeTensorSignatureDef
        ): )
      compound_statement: {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_composite_tensor()->add_components()->set_name("input1:0");
  in.mutable_composite_tensor()->add_components()->set_name("input2:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_composite_tensor()->add_components()->set_name("output2:0");
  out.mutable_composite_tensor()->add_components()->set_name("output1:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
       {: {
       comment: // Test that inputs and outputs get correctly populated for a
       comment: // SignatureDef containing composite tensor inputs and outputs.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: SignatureDef signature_def;
        type_identifier: SignatureDef
        identifier: signature_def
        ;: ;
       declaration: TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
        type_identifier: TensorInfo
        init_declarator: & in = (*signature_def.mutable_inputs())["input_arg"]
         reference_declarator: & in
          &: &
          identifier: in
         =: =
         subscript_expression: (*signature_def.mutable_inputs())["input_arg"]
          parenthesized_expression: (*signature_def.mutable_inputs())
           (: (
           pointer_expression: *signature_def.mutable_inputs()
            *: *
            call_expression: signature_def.mutable_inputs()
             field_expression: signature_def.mutable_inputs
              identifier: signature_def
              .: .
              field_identifier: mutable_inputs
             argument_list: ()
              (: (
              ): )
           ): )
          subscript_argument_list: ["input_arg"]
           [: [
           string_literal: "input_arg"
            ": "
            string_content: input_arg
            ": "
           ]: ]
        ;: ;
       expression_statement: in.mutable_composite_tensor()->add_components()->set_name("input1:0");
        call_expression: in.mutable_composite_tensor()->add_components()->set_name("input1:0")
         field_expression: in.mutable_composite_tensor()->add_components()->set_name
          call_expression: in.mutable_composite_tensor()->add_components()
           field_expression: in.mutable_composite_tensor()->add_components
            call_expression: in.mutable_composite_tensor()
             field_expression: in.mutable_composite_tensor
              identifier: in
              .: .
              field_identifier: mutable_composite_tensor
             argument_list: ()
              (: (
              ): )
            ->: ->
            field_identifier: add_components
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_name
         argument_list: ("input1:0")
          (: (
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          ): )
        ;: ;
       expression_statement: in.mutable_composite_tensor()->add_components()->set_name("input2:0");
        call_expression: in.mutable_composite_tensor()->add_components()->set_name("input2:0")
         field_expression: in.mutable_composite_tensor()->add_components()->set_name
          call_expression: in.mutable_composite_tensor()->add_components()
           field_expression: in.mutable_composite_tensor()->add_components
            call_expression: in.mutable_composite_tensor()
             field_expression: in.mutable_composite_tensor
              identifier: in
              .: .
              field_identifier: mutable_composite_tensor
             argument_list: ()
              (: (
              ): )
            ->: ->
            field_identifier: add_components
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_name
         argument_list: ("input2:0")
          (: (
          string_literal: "input2:0"
           ": "
           string_content: input2:0
           ": "
          ): )
        ;: ;
       declaration: TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
        type_identifier: TensorInfo
        init_declarator: & out = (*signature_def.mutable_outputs())["output_arg"]
         reference_declarator: & out
          &: &
          identifier: out
         =: =
         subscript_expression: (*signature_def.mutable_outputs())["output_arg"]
          parenthesized_expression: (*signature_def.mutable_outputs())
           (: (
           pointer_expression: *signature_def.mutable_outputs()
            *: *
            call_expression: signature_def.mutable_outputs()
             field_expression: signature_def.mutable_outputs
              identifier: signature_def
              .: .
              field_identifier: mutable_outputs
             argument_list: ()
              (: (
              ): )
           ): )
          subscript_argument_list: ["output_arg"]
           [: [
           string_literal: "output_arg"
            ": "
            string_content: output_arg
            ": "
           ]: ]
        ;: ;
       expression_statement: out.mutable_composite_tensor()->add_components()->set_name("output2:0");
        call_expression: out.mutable_composite_tensor()->add_components()->set_name("output2:0")
         field_expression: out.mutable_composite_tensor()->add_components()->set_name
          call_expression: out.mutable_composite_tensor()->add_components()
           field_expression: out.mutable_composite_tensor()->add_components
            call_expression: out.mutable_composite_tensor()
             field_expression: out.mutable_composite_tensor
              identifier: out
              .: .
              field_identifier: mutable_composite_tensor
             argument_list: ()
              (: (
              ): )
            ->: ->
            field_identifier: add_components
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_name
         argument_list: ("output2:0")
          (: (
          string_literal: "output2:0"
           ": "
           string_content: output2:0
           ": "
          ): )
        ;: ;
       expression_statement: out.mutable_composite_tensor()->add_components()->set_name("output1:0");
        call_expression: out.mutable_composite_tensor()->add_components()->set_name("output1:0")
         field_expression: out.mutable_composite_tensor()->add_components()->set_name
          call_expression: out.mutable_composite_tensor()->add_components()
           field_expression: out.mutable_composite_tensor()->add_components
            call_expression: out.mutable_composite_tensor()
             field_expression: out.mutable_composite_tensor
              identifier: out
              .: .
              field_identifier: mutable_composite_tensor
             argument_list: ()
              (: (
              ): )
            ->: ->
            field_identifier: add_components
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_name
         argument_list: ("output1:0")
          (: (
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          ): )
        ;: ;
       expression_statement: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
        call_expression: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle)
         identifier: AddSignatureDefToSavedModelBundle
         argument_list: (signature_def, "signature_def",
                                    &saved_model_bundle)
          (: (
          identifier: signature_def
          ,: ,
          string_literal: "signature_def"
           ": "
           string_content: signature_def
           ": "
          ,: ,
          pointer_expression: &saved_model_bundle
           &: &
           identifier: saved_model_bundle
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       declaration: std::unordered_set<string> expected_inputs = {"input1:0", "input2:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_inputs = {"input1:0", "input2:0"}
         identifier: expected_inputs
         =: =
         initializer_list: {"input1:0", "input2:0"}
          {: {
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          ,: ,
          string_literal: "input2:0"
           ": "
           string_content: input2:0
           ": "
          }: }
        ;: ;
       declaration: std::unordered_set<string> expected_outputs = {"output1:0", "output2:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_outputs = {"output1:0", "output2:0"}
         identifier: expected_outputs
         =: =
         initializer_list: {"output1:0", "output2:0"}
          {: {
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          ,: ,
          string_literal: "output2:0"
           ": "
           string_content: output2:0
           ": "
          }: }
        ;: ;
       expression_statement: EXPECT_EQ(expected_inputs, inputs);
        call_expression: EXPECT_EQ(expected_inputs, inputs)
         identifier: EXPECT_EQ
         argument_list: (expected_inputs, inputs)
          (: (
          identifier: expected_inputs
          ,: ,
          identifier: inputs
          ): )
        ;: ;
       expression_statement: EXPECT_EQ(expected_outputs, outputs);
        call_expression: EXPECT_EQ(expected_outputs, outputs)
         identifier: EXPECT_EQ
         argument_list: (expected_outputs, outputs)
          (: (
          identifier: expected_outputs
          ,: ,
          identifier: outputs
          ): )
        ;: ;
       }: }
     function_definition: TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef) {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
      function_declarator: TEST_F(FreezeTest, InputsAndOutputsSparseCooSignatureDef)
       identifier: TEST_F
       parameter_list: (FreezeTest, InputsAndOutputsSparseCooSignatureDef)
        (: (
        parameter_declaration: FreezeTest
         type_identifier: FreezeTest
        ,: ,
        parameter_declaration: InputsAndOutputsSparseCooSignatureDef
         type_identifier: InputsAndOutputsSparseCooSignatureDef
        ): )
      compound_statement: {
  // Test that inputs and outputs get correctly populated for a
  // SignatureDef containing composite tensor inputs and outputs.
  SavedModelBundle saved_model_bundle;
  SignatureDef signature_def;

  TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
  in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
  in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
  in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");

  TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
  out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
  out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
  out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");

  AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
  GraphDef frozen_graph_def;
  std::unordered_set<string> inputs;
  std::unordered_set<string> outputs;
  TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
  std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
  std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
  EXPECT_EQ(expected_inputs, inputs);
  EXPECT_EQ(expected_outputs, outputs);
}
       {: {
       comment: // Test that inputs and outputs get correctly populated for a
       comment: // SignatureDef containing composite tensor inputs and outputs.
       declaration: SavedModelBundle saved_model_bundle;
        type_identifier: SavedModelBundle
        identifier: saved_model_bundle
        ;: ;
       declaration: SignatureDef signature_def;
        type_identifier: SignatureDef
        identifier: signature_def
        ;: ;
       declaration: TensorInfo& in = (*signature_def.mutable_inputs())["input_arg"];
        type_identifier: TensorInfo
        init_declarator: & in = (*signature_def.mutable_inputs())["input_arg"]
         reference_declarator: & in
          &: &
          identifier: in
         =: =
         subscript_expression: (*signature_def.mutable_inputs())["input_arg"]
          parenthesized_expression: (*signature_def.mutable_inputs())
           (: (
           pointer_expression: *signature_def.mutable_inputs()
            *: *
            call_expression: signature_def.mutable_inputs()
             field_expression: signature_def.mutable_inputs
              identifier: signature_def
              .: .
              field_identifier: mutable_inputs
             argument_list: ()
              (: (
              ): )
           ): )
          subscript_argument_list: ["input_arg"]
           [: [
           string_literal: "input_arg"
            ": "
            string_content: input_arg
            ": "
           ]: ]
        ;: ;
       expression_statement: in.mutable_coo_sparse()->set_values_tensor_name("input1:0");
        call_expression: in.mutable_coo_sparse()->set_values_tensor_name("input1:0")
         field_expression: in.mutable_coo_sparse()->set_values_tensor_name
          call_expression: in.mutable_coo_sparse()
           field_expression: in.mutable_coo_sparse
            identifier: in
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_values_tensor_name
         argument_list: ("input1:0")
          (: (
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          ): )
        ;: ;
       expression_statement: in.mutable_coo_sparse()->set_indices_tensor_name("input2:0");
        call_expression: in.mutable_coo_sparse()->set_indices_tensor_name("input2:0")
         field_expression: in.mutable_coo_sparse()->set_indices_tensor_name
          call_expression: in.mutable_coo_sparse()
           field_expression: in.mutable_coo_sparse
            identifier: in
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_indices_tensor_name
         argument_list: ("input2:0")
          (: (
          string_literal: "input2:0"
           ": "
           string_content: input2:0
           ": "
          ): )
        ;: ;
       expression_statement: in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0");
        call_expression: in.mutable_coo_sparse()->set_dense_shape_tensor_name("input3:0")
         field_expression: in.mutable_coo_sparse()->set_dense_shape_tensor_name
          call_expression: in.mutable_coo_sparse()
           field_expression: in.mutable_coo_sparse
            identifier: in
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_dense_shape_tensor_name
         argument_list: ("input3:0")
          (: (
          string_literal: "input3:0"
           ": "
           string_content: input3:0
           ": "
          ): )
        ;: ;
       declaration: TensorInfo& out = (*signature_def.mutable_outputs())["output_arg"];
        type_identifier: TensorInfo
        init_declarator: & out = (*signature_def.mutable_outputs())["output_arg"]
         reference_declarator: & out
          &: &
          identifier: out
         =: =
         subscript_expression: (*signature_def.mutable_outputs())["output_arg"]
          parenthesized_expression: (*signature_def.mutable_outputs())
           (: (
           pointer_expression: *signature_def.mutable_outputs()
            *: *
            call_expression: signature_def.mutable_outputs()
             field_expression: signature_def.mutable_outputs
              identifier: signature_def
              .: .
              field_identifier: mutable_outputs
             argument_list: ()
              (: (
              ): )
           ): )
          subscript_argument_list: ["output_arg"]
           [: [
           string_literal: "output_arg"
            ": "
            string_content: output_arg
            ": "
           ]: ]
        ;: ;
       expression_statement: out.mutable_coo_sparse()->set_values_tensor_name("output1:0");
        call_expression: out.mutable_coo_sparse()->set_values_tensor_name("output1:0")
         field_expression: out.mutable_coo_sparse()->set_values_tensor_name
          call_expression: out.mutable_coo_sparse()
           field_expression: out.mutable_coo_sparse
            identifier: out
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_values_tensor_name
         argument_list: ("output1:0")
          (: (
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          ): )
        ;: ;
       expression_statement: out.mutable_coo_sparse()->set_indices_tensor_name("output2:0");
        call_expression: out.mutable_coo_sparse()->set_indices_tensor_name("output2:0")
         field_expression: out.mutable_coo_sparse()->set_indices_tensor_name
          call_expression: out.mutable_coo_sparse()
           field_expression: out.mutable_coo_sparse
            identifier: out
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_indices_tensor_name
         argument_list: ("output2:0")
          (: (
          string_literal: "output2:0"
           ": "
           string_content: output2:0
           ": "
          ): )
        ;: ;
       expression_statement: out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0");
        call_expression: out.mutable_coo_sparse()->set_dense_shape_tensor_name("output3:0")
         field_expression: out.mutable_coo_sparse()->set_dense_shape_tensor_name
          call_expression: out.mutable_coo_sparse()
           field_expression: out.mutable_coo_sparse
            identifier: out
            .: .
            field_identifier: mutable_coo_sparse
           argument_list: ()
            (: (
            ): )
          ->: ->
          field_identifier: set_dense_shape_tensor_name
         argument_list: ("output3:0")
          (: (
          string_literal: "output3:0"
           ": "
           string_content: output3:0
           ": "
          ): )
        ;: ;
       expression_statement: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle);
        call_expression: AddSignatureDefToSavedModelBundle(signature_def, "signature_def",
                                    &saved_model_bundle)
         identifier: AddSignatureDefToSavedModelBundle
         argument_list: (signature_def, "signature_def",
                                    &saved_model_bundle)
          (: (
          identifier: signature_def
          ,: ,
          string_literal: "signature_def"
           ": "
           string_content: signature_def
           ": "
          ,: ,
          pointer_expression: &saved_model_bundle
           &: &
           identifier: saved_model_bundle
          ): )
        ;: ;
       declaration: GraphDef frozen_graph_def;
        type_identifier: GraphDef
        identifier: frozen_graph_def
        ;: ;
       declaration: std::unordered_set<string> inputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: inputs
        ;: ;
       declaration: std::unordered_set<string> outputs;
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        identifier: outputs
        ;: ;
       expression_statement: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs));
        call_expression: TF_ASSERT_OK(FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
         identifier: TF_ASSERT_OK
         argument_list: (FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs))
          (: (
          call_expression: FreezeSavedModel(saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
           identifier: FreezeSavedModel
           argument_list: (saved_model_bundle, &frozen_graph_def, &inputs,
                                &outputs)
            (: (
            identifier: saved_model_bundle
            ,: ,
            pointer_expression: &frozen_graph_def
             &: &
             identifier: frozen_graph_def
            ,: ,
            pointer_expression: &inputs
             &: &
             identifier: inputs
            ,: ,
            pointer_expression: &outputs
             &: &
             identifier: outputs
            ): )
          ): )
        ;: ;
       declaration: std::unordered_set<string> expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_inputs = {"input1:0", "input2:0",
                                                "input3:0"}
         identifier: expected_inputs
         =: =
         initializer_list: {"input1:0", "input2:0",
                                                "input3:0"}
          {: {
          string_literal: "input1:0"
           ": "
           string_content: input1:0
           ": "
          ,: ,
          string_literal: "input2:0"
           ": "
           string_content: input2:0
           ": "
          ,: ,
          string_literal: "input3:0"
           ": "
           string_content: input3:0
           ": "
          }: }
        ;: ;
       declaration: std::unordered_set<string> expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"};
        qualified_identifier: std::unordered_set<string>
         namespace_identifier: std
         ::: ::
         template_type: unordered_set<string>
          type_identifier: unordered_set
          template_argument_list: <string>
           <: <
           type_descriptor: string
            type_identifier: string
           >: >
        init_declarator: expected_outputs = {"output1:0", "output2:0",
                                                 "output3:0"}
         identifier: expected_outputs
         =: =
         initializer_list: {"output1:0", "output2:0",
                                                 "output3:0"}
          {: {
          string_literal: "output1:0"
           ": "
           string_content: output1:0
           ": "
          ,: ,
          string_literal: "output2:0"
           ": "
           string_content: output2:0
           ": "
          ,: ,
          string_literal: "output3:0"
           ": "
           string_content: output3:0
           ": "
          }: }
        ;: ;
       expression_statement: EXPECT_EQ(expected_inputs, inputs);
        call_expression: EXPECT_EQ(expected_inputs, inputs)
         identifier: EXPECT_EQ
         argument_list: (expected_inputs, inputs)
          (: (
          identifier: expected_inputs
          ,: ,
          identifier: inputs
          ): )
        ;: ;
       expression_statement: EXPECT_EQ(expected_outputs, outputs);
        call_expression: EXPECT_EQ(expected_outputs, outputs)
         identifier: EXPECT_EQ
         argument_list: (expected_outputs, outputs)
          (: (
          identifier: expected_outputs
          ,: ,
          identifier: outputs
          ): )
        ;: ;
       }: }
     }: }
   comment: // namespace
   }: }
 comment: // namespace tensorflow
